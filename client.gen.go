// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "apiKeyAuth.Scopes"
	HttpAuthScopes   = "httpAuth.Scopes"
)

// AllocatePartyRequest Required authorization: “HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)“
type AllocatePartyRequest struct {
	// IdentityProviderId The id of the ``Identity Provider``
	// Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
	IdentityProviderId string `json:"identityProviderId"`

	// LocalMetadata Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
	//
	// Based on ``ObjectMeta`` meta used in Kubernetes API.
	// See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640
	LocalMetadata *ObjectMeta `json:"localMetadata,omitempty"`

	// PartyIdHint A hint to the participant which party ID to allocate. It can be
	// ignored.
	// Must be a valid PartyIdString (as described in ``value.proto``).
	// Optional
	PartyIdHint string `json:"partyIdHint"`
}

// AllocatePartyResponse defines model for AllocatePartyResponse.
type AllocatePartyResponse struct {
	PartyDetails *PartyDetails `json:"partyDetails,omitempty"`
}

// Any defines model for Any.
type Any struct {
	TypeUrl       string `json:"typeUrl"`
	UnknownFields string `json:"unknownFields"`
	Value         string `json:"value"`
}

// ArchivedEvent Records that a contract has been archived, and choices may no longer be exercised on it.
type ArchivedEvent struct {
	// ContractId The ID of the archived contract.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	ContractId string `json:"contractId"`

	// ImplementedInterfaces The interfaces implemented by the target template that have been
	// matched from the interface filter query.
	// Populated only in case interface filters with include_interface_view set.
	//
	// If defined, the identifier uses the package-id reference format.
	//
	// Optional
	ImplementedInterfaces *[]string `json:"implementedInterfaces,omitempty"`

	// NodeId The position of this event in the originating transaction or reassignment.
	// Node IDs are not necessarily equal across participants,
	// as these may see different projections/parts of transactions.
	// Required, must be valid node ID (non-negative integer)
	NodeId int32 `json:"nodeId"`

	// Offset The offset of origin.
	// Offsets are managed by the participant nodes.
	// Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
	// Required, it is a valid absolute offset (positive integer)
	Offset int64 `json:"offset"`

	// PackageName The package name of the contract.
	// Required
	PackageName string `json:"packageName"`

	// TemplateId The template of the archived contract.
	// The identifier uses the package-id reference format.
	//
	// Required
	TemplateId string `json:"templateId"`

	// WitnessParties The parties that are notified of this event. For an ``ArchivedEvent``,
	// these are the intersection of the stakeholders of the contract in
	// question and the parties specified in the ``TransactionFilter``. The
	// stakeholders are the union of the signatories and the observers of
	// the contract.
	// Each one of its elements must be a valid PartyIdString (as described
	// in ``value.proto``).
	// Required
	WitnessParties *[]string `json:"witnessParties,omitempty"`
}

// AssignCommand Assign a contract
type AssignCommand struct {
	// Value Assign a contract
	Value AssignCommand1 `json:"value"`
}

// AssignCommand1 Assign a contract
type AssignCommand1 struct {
	// Source The ID of the source synchronizer
	// Must be a valid synchronizer id
	// Required
	Source string `json:"source"`

	// Target The ID of the target synchronizer
	// Must be a valid synchronizer id
	// Required
	Target string `json:"target"`

	// UnassignId The ID from the unassigned event to be completed by this assignment.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UnassignId string `json:"unassignId"`
}

// CanActAs defines model for CanActAs.
type CanActAs struct {
	Value CanActAs1 `json:"value"`
}

// CanActAs1 defines model for CanActAs1.
type CanActAs1 struct {
	Party string `json:"party"`
}

// CanReadAs defines model for CanReadAs.
type CanReadAs struct {
	Value CanReadAs1 `json:"value"`
}

// CanReadAs1 defines model for CanReadAs1.
type CanReadAs1 struct {
	Party string `json:"party"`
}

// CanReadAsAnyParty defines model for CanReadAsAnyParty.
type CanReadAsAnyParty struct {
	Value CanReadAsAnyParty1 `json:"value"`
}

// CanReadAsAnyParty1 defines model for CanReadAsAnyParty1.
type CanReadAsAnyParty1 = map[string]interface{}

// Command A command can either create a new contract or exercise a choice on an existing contract.
type Command struct {
	union json.RawMessage
}

// Command0 defines model for .
type Command0 struct {
	// CreateAndExerciseCommand Create a contract and exercise a choice on it in the same transaction.
	CreateAndExerciseCommand CreateAndExerciseCommand `json:"CreateAndExerciseCommand"`
}

// Command1 defines model for .
type Command1 struct {
	// CreateCommand Create a new contract instance based on a template.
	CreateCommand CreateCommand `json:"CreateCommand"`
}

// Command2 defines model for .
type Command2 struct {
	// ExerciseByKeyCommand Exercise a choice on an existing contract specified by its key.
	ExerciseByKeyCommand ExerciseByKeyCommand `json:"ExerciseByKeyCommand"`
}

// Command3 defines model for .
type Command3 struct {
	// ExerciseCommand Exercise a choice on an existing contract.
	ExerciseCommand ExerciseCommand `json:"ExerciseCommand"`
}

// ReassignmentCommandUnion A command can either create a new contract or exercise a choice on an existing contract.
type ReassignmentCommandUnion struct {
	union json.RawMessage
}

// Command10 defines model for .
type Command10 struct {
	// AssignCommand Assign a contract
	AssignCommand AssignCommand `json:"AssignCommand"`
}

// Command11 defines model for .
type Command11 struct {
	Empty Empty2 `json:"Empty"`
}

// Command12 defines model for .
type Command12 struct {
	// UnassignCommand Unassign a contract
	UnassignCommand UnassignCommand `json:"UnassignCommand"`
}

// Completion A completion represents the status of a submitted command on the ledger: it can be successful or failed.
type Completion struct {
	// Value A completion represents the status of a submitted command on the ledger: it can be successful or failed.
	Value Completion1 `json:"value"`
}

// Completion1 A completion represents the status of a submitted command on the ledger: it can be successful or failed.
type Completion1 struct {
	// ActAs The set of parties on whose behalf the commands were executed.
	// Contains the ``act_as`` parties from ``commands.proto``
	// filtered to the requesting parties in CompletionStreamRequest.
	// The order of the parties need not be the same as in the submission.
	// Each element must be a valid PartyIdString (as described in ``value.proto``).
	// Optional for historic completions where this data is not available.
	ActAs *[]string `json:"actAs,omitempty"`

	// CommandId The ID of the succeeded or failed command.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	CommandId string `json:"commandId"`

	// CompletionDeduplicationPeriod Specifies the deduplication period for the change ID.
	// If omitted, the participant will assume the configured maximum deduplication time.
	CompletionDeduplicationPeriod CompletionDeduplicationPeriod `json:"deduplicationPeriod"`

	// Offset May be used in a subsequent CompletionStreamRequest to resume the consumption of this stream at a later time.
	// Required, must be a valid absolute offset (positive integer).
	Offset int64   `json:"offset"`
	Status *Status `json:"status,omitempty"`

	// SubmissionId The submission ID this completion refers to, as described in ``commands.proto``.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	SubmissionId     string            `json:"submissionId"`
	SynchronizerTime *SynchronizerTime `json:"synchronizerTime,omitempty"`
	TraceContext     *TraceContext     `json:"traceContext,omitempty"`

	// UpdateId The update_id of the transaction or reassignment that resulted from the command with command_id.
	// Only set for successfully executed commands.
	// Must be a valid LedgerString (as described in ``value.proto``).
	UpdateId string `json:"updateId"`

	// UserId The user-id that was used for the submission, as described in ``commands.proto``.
	// Must be a valid UserIdString (as described in ``value.proto``).
	// Optional for historic completions where this data is not available.
	UserId string `json:"userId"`
}

// CompletionResponse defines model for CompletionResponse.
type CompletionResponse struct {
	union json.RawMessage
}

// CompletionResponse0 defines model for .
type CompletionResponse0 struct {
	// Completion A completion represents the status of a submitted command on the ledger: it can be successful or failed.
	Completion Completion `json:"Completion"`
}

// CompletionResponse1 defines model for .
type CompletionResponse1 struct {
	Empty Empty4 `json:"Empty"`
}

// CompletionResponse2 defines model for .
type CompletionResponse2 struct {
	// OffsetCheckpoint OffsetCheckpoints may be used to:
	//
	// - detect time out of commands.
	// - provide an offset which can be used to restart consumption.
	OffsetCheckpoint OffsetCheckpoint `json:"OffsetCheckpoint"`
}

// CompletionStreamRequest defines model for CompletionStreamRequest.
type CompletionStreamRequest struct {
	// BeginExclusive This optional field indicates the minimum offset for completions. This can be used to resume an earlier completion stream.
	// If not set the ledger uses the ledger begin offset instead.
	// If specified, it must be a valid absolute offset (positive integer) or zero (ledger begin offset).
	// If the ledger has been pruned, this parameter must be specified and greater than the pruning offset.
	BeginExclusive int64 `json:"beginExclusive"`

	// Parties Non-empty list of parties whose data should be included.
	// The stream shows only completions of commands for which at least one of the ``act_as`` parties is in the given set of parties.
	// Must be a valid PartyIdString (as described in ``value.proto``).
	// Required
	Parties *[]string `json:"parties,omitempty"`

	// UserId Only completions of commands submitted with the same user_id will be visible in the stream.
	// Must be a valid UserIdString (as described in ``value.proto``).
	// Required unless authentication is used with a user token.
	// In that case, the token's user-id will be used for the request's user_id.
	UserId string `json:"userId"`
}

// CompletionStreamResponse defines model for CompletionStreamResponse.
type CompletionStreamResponse struct {
	CompletionResponse CompletionResponse `json:"completionResponse"`
}

// ConnectedSynchronizer defines model for ConnectedSynchronizer.
type ConnectedSynchronizer struct {
	Permission        ParticipantPermission `json:"permission"`
	SynchronizerAlias string                `json:"synchronizerAlias"`
	SynchronizerId    string                `json:"synchronizerId"`
}

// CreateAndExerciseCommand Create a contract and exercise a choice on it in the same transaction.
type CreateAndExerciseCommand struct {
	// Choice The name of the choice the client wants to exercise.
	// Must be a valid NameString (as described in ``value.proto``).
	// Required
	Choice string `json:"choice"`

	// ChoiceArgument The argument for this choice.
	// Required
	ChoiceArgument interface{} `json:"choiceArgument"`

	// CreateArguments The arguments required for creating a contract from this template.
	// Required
	CreateArguments interface{} `json:"createArguments"`

	// TemplateId The template of the contract the client wants to create.
	// Both package-name and package-id reference identifier formats for the template-id are supported.
	// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
	//
	// Required
	TemplateId string `json:"templateId"`
}

// CreateCommand Create a new contract instance based on a template.
type CreateCommand struct {
	// CreateArguments The arguments required for creating a contract from this template.
	// Required
	CreateArguments interface{} `json:"createArguments"`

	// TemplateId The template of contract the client wants to create.
	// Both package-name and package-id reference identifier formats for the template-id are supported.
	// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
	//
	// Required
	TemplateId string `json:"templateId"`
}

// CreateIdentityProviderConfigRequest defines model for CreateIdentityProviderConfigRequest.
type CreateIdentityProviderConfigRequest struct {
	IdentityProviderConfig *IdentityProviderConfig `json:"identityProviderConfig,omitempty"`
}

// CreateIdentityProviderConfigResponse defines model for CreateIdentityProviderConfigResponse.
type CreateIdentityProviderConfigResponse struct {
	IdentityProviderConfig *IdentityProviderConfig `json:"identityProviderConfig,omitempty"`
}

// CreateUserRequest  RPC requests and responses
// ///////////////////////////
//
//	Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
type CreateUserRequest struct {
	// Rights The rights to be assigned to the user upon creation,
	// which SHOULD include appropriate rights for the ``user.primary_party``.
	// Optional
	Rights *[]Right `json:"rights,omitempty"`

	// User  Users and rights
	// /////////////////
	//  Users are used to dynamically manage the rights given to Daml applications.
	//  They are stored and managed per participant node.
	User *User `json:"user,omitempty"`
}

// CreateUserResponse defines model for CreateUserResponse.
type CreateUserResponse struct {
	// User  Users and rights
	// /////////////////
	//  Users are used to dynamically manage the rights given to Daml applications.
	//  They are stored and managed per participant node.
	User *User `json:"user,omitempty"`
}

// CreatedEvent Records that a contract has been created, and choices may now be exercised on it.
type CreatedEvent struct {
	// ContractId The ID of the created contract.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	ContractId string `json:"contractId"`

	// ContractKey The key of the created contract.
	// This will be set if and only if ``create_arguments`` is set and ``template_id`` defines a contract key.
	// Optional
	ContractKey    interface{} `json:"contractKey,omitempty"`
	CreateArgument interface{} `json:"createArgument,omitempty"`

	// CreatedAt Ledger effective time of the transaction that created the contract.
	// Required
	CreatedAt string `json:"createdAt"`

	// CreatedEventBlob Opaque representation of contract create event payload intended for forwarding
	// to an API server as a contract disclosed as part of a command
	// submission.
	// Optional
	CreatedEventBlob string `json:"createdEventBlob"`

	// InterfaceViews Interface views specified in the transaction filter.
	// Includes an ``InterfaceView`` for each interface for which there is a ``InterfaceFilter`` with
	//
	// - its party in the ``witness_parties`` of this event,
	// - and which is implemented by the template of this event,
	// - and which has ``include_interface_view`` set.
	//
	// Optional
	InterfaceViews *[]JsInterfaceView `json:"interfaceViews,omitempty"`

	// NodeId The position of this event in the originating transaction or reassignment.
	// The origin has contextual meaning, please see description at messages that include a CreatedEvent.
	// Node IDs are not necessarily equal across participants,
	// as these may see different projections/parts of transactions.
	// Required, must be valid node ID (non-negative integer)
	NodeId int32 `json:"nodeId"`

	// Observers The observers for this contract as specified explicitly by the template or implicitly as choice controllers.
	// This field never contains parties that are signatories.
	// Required
	Observers *[]string `json:"observers,omitempty"`

	// Offset The offset of origin, which has contextual meaning, please see description at messages that include a CreatedEvent.
	// Offsets are managed by the participant nodes.
	// Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
	// Required, it is a valid absolute offset (positive integer)
	Offset int64 `json:"offset"`

	// PackageName The package name of the created contract.
	// Required
	PackageName string `json:"packageName"`

	// Signatories The signatories for this contract as specified by the template.
	// Required
	Signatories *[]string `json:"signatories,omitempty"`

	// TemplateId The template of the created contract.
	// The identifier uses the package-id reference format.
	//
	// Required
	TemplateId string `json:"templateId"`

	// WitnessParties The parties that are notified of this event. When a ``CreatedEvent``
	// is returned as part of a transaction tree or ledger-effects transaction, this will include all
	// the parties specified in the ``TransactionFilter`` that are informees
	// of the event. If served as part of a ACS delta transaction those will
	// be limited to all parties specified in the ``TransactionFilter`` that
	// are stakeholders of the contract (i.e. either signatories or observers).
	// If the ``CreatedEvent`` is returned as part of an AssignedEvent,
	// ActiveContract or IncompleteUnassigned (so the event is related to
	// an assignment or unassignment): this will include all parties of the
	// ``TransactionFilter`` that are stakeholders of the contract.
	//
	// The behavior of reading create events visible to parties not hosted
	// on the participant node serving the Ledger API is undefined. Concretely,
	// there is neither a guarantee that the participant node will serve all their
	// create events on the ACS stream, nor is there a guarantee that matching archive
	// events are delivered for such create events.
	//
	// For most clients this is not a problem, as they only read events for parties
	// that are hosted on the participant node. If you need to read events
	// for parties that may not be hosted at all times on the participant node,
	// subscribe to the ``TopologyEvent``s for that party by setting a corresponding
	// ``UpdateFormat``.  Using these events, query the ACS as-of an offset where the
	// party is hosted on the participant node, and ignore create events at offsets
	// where the party is not hosted on the participant node.
	// Required
	WitnessParties *[]string `json:"witnessParties,omitempty"`
}

// CreatedTreeEvent defines model for CreatedTreeEvent.
type CreatedTreeEvent struct {
	// Value Records that a contract has been created, and choices may now be exercised on it.
	Value CreatedEvent `json:"value"`
}

// CumulativeFilter A filter that matches all contracts that are either an instance of one of
// the “template_filters“ or that match one of the “interface_filters“.
type CumulativeFilter struct {
	IdentifierFilter IdentifierFilter `json:"identifierFilter"`
}

// DeduplicationDuration defines model for DeduplicationDuration.
type DeduplicationDuration struct {
	Value Duration `json:"value"`
}

// DeduplicationDuration1 defines model for DeduplicationDuration1.
type DeduplicationDuration1 struct {
	Value Duration `json:"value"`
}

// DeduplicationDuration2 defines model for DeduplicationDuration2.
type DeduplicationDuration2 struct {
	Value Duration `json:"value"`
}

// DeduplicationOffset defines model for DeduplicationOffset.
type DeduplicationOffset struct {
	Value int64 `json:"value"`
}

// DeduplicationOffset1 defines model for DeduplicationOffset1.
type DeduplicationOffset1 struct {
	Value int64 `json:"value"`
}

// DeduplicationOffset2 defines model for DeduplicationOffset2.
type DeduplicationOffset2 struct {
	Value int64 `json:"value"`
}

// DeduplicationPeriod Specifies the deduplication period for the change ID.
// If omitted, the participant will assume the configured maximum deduplication time.
type DeduplicationPeriod struct {
	union json.RawMessage
}

// DeduplicationPeriod0 defines model for .
type DeduplicationPeriod0 struct {
	DeduplicationDuration DeduplicationDuration `json:"DeduplicationDuration"`
}

// DeduplicationPeriod1 defines model for .
type DeduplicationPeriod1 struct {
	DeduplicationOffset DeduplicationOffset `json:"DeduplicationOffset"`
}

// DeduplicationPeriod2 defines model for .
type DeduplicationPeriod2 struct {
	Empty Empty `json:"Empty"`
}

// CompletionDeduplicationPeriod Specifies the deduplication period for the change ID.
// If omitted, the participant will assume the configured maximum deduplication time.
type CompletionDeduplicationPeriod struct {
	union json.RawMessage
}

// DeduplicationPeriod10 defines model for .
type DeduplicationPeriod10 struct {
	DeduplicationDuration DeduplicationDuration1 `json:"DeduplicationDuration"`
}

// DeduplicationPeriod11 defines model for .
type DeduplicationPeriod11 struct {
	DeduplicationOffset DeduplicationOffset1 `json:"DeduplicationOffset"`
}

// DeduplicationPeriod12 defines model for .
type DeduplicationPeriod12 struct {
	Empty Empty3 `json:"Empty"`
}

// TransactionDeduplicationPeriod Specifies the deduplication period for the change ID.
// If omitted, the participant will assume the configured maximum deduplication time.
type TransactionDeduplicationPeriod struct {
	union json.RawMessage
}

// DeduplicationPeriod20 defines model for .
type DeduplicationPeriod20 struct {
	DeduplicationDuration DeduplicationDuration2 `json:"DeduplicationDuration"`
}

// DeduplicationPeriod21 defines model for .
type DeduplicationPeriod21 struct {
	DeduplicationOffset DeduplicationOffset2 `json:"DeduplicationOffset"`
}

// DeduplicationPeriod22 defines model for .
type DeduplicationPeriod22 struct {
	Empty Empty7 `json:"Empty"`
}

// DeleteIdentityProviderConfigResponse Does not (yet) contain any data.
type DeleteIdentityProviderConfigResponse = map[string]interface{}

// DisclosedContract An additional contract that is used to resolve
// contract & contract key lookups.
type DisclosedContract struct {
	// ContractId The contract id
	// Required
	ContractId string `json:"contractId"`

	// CreatedEventBlob Opaque byte string containing the complete payload required by the Daml engine
	// to reconstruct a contract not known to the receiving participant.
	// Required
	CreatedEventBlob string `json:"createdEventBlob"`

	// SynchronizerId The ID of the synchronizer where the contract is currently assigned
	// Optional
	SynchronizerId string `json:"synchronizerId"`

	// TemplateId The template id of the contract.
	// The identifier uses the package-id reference format.
	//
	// Required
	TemplateId *string `json:"templateId,omitempty"`
}

// Duration defines model for Duration.
type Duration struct {
	Nanos   int32 `json:"nanos"`
	Seconds int64 `json:"seconds"`

	// UnknownFields This field is automatically added as part of protobuf to json mapping
	UnknownFields *string `json:"unknownFields,omitempty"`
}

// Empty defines model for Empty.
type Empty = map[string]interface{}

// Empty1 defines model for Empty1.
type Empty1 = map[string]interface{}

// Empty2 defines model for Empty2.
type Empty2 = map[string]interface{}

// Empty3 defines model for Empty3.
type Empty3 = map[string]interface{}

// Empty4 defines model for Empty4.
type Empty4 = map[string]interface{}

// Empty5 defines model for Empty5.
type Empty5 = map[string]interface{}

// Empty6 defines model for Empty6.
type Empty6 = map[string]interface{}

// Empty7 defines model for Empty7.
type Empty7 = map[string]interface{}

// Event Events in transactions can have two primary shapes:
//
// - ACS delta: events can be CreatedEvent or ArchivedEvent
// - ledger effects: events can be CreatedEvent or ExercisedEvent
//
// In the update service the events are restricted to the events
// visible for the parties specified in the transaction filter. Each
// event message type below contains a “witness_parties“ field which
// indicates the subset of the requested parties that can see the event
// in question.
type Event struct {
	union json.RawMessage
}

// Event0 defines model for .
type Event0 struct {
	// ArchivedEvent Records that a contract has been archived, and choices may no longer be exercised on it.
	ArchivedEvent ArchivedEvent `json:"ArchivedEvent"`
}

// Event1 defines model for .
type Event1 struct {
	// CreatedEvent Records that a contract has been created, and choices may now be exercised on it.
	CreatedEvent CreatedEvent `json:"CreatedEvent"`
}

// Event2 defines model for .
type Event2 struct {
	// ExercisedEvent Records that a choice has been exercised on a target contract.
	ExercisedEvent ExercisedEvent `json:"ExercisedEvent"`
}

// ParticipantEvent Events in transactions can have two primary shapes:
//
// - ACS delta: events can be CreatedEvent or ArchivedEvent
// - ledger effects: events can be CreatedEvent or ExercisedEvent
//
// In the update service the events are restricted to the events
// visible for the parties specified in the transaction filter. Each
// event message type below contains a “witness_parties“ field which
// indicates the subset of the requested parties that can see the event
// in question.
type ParticipantEvent struct {
	union json.RawMessage
}

// EventFormat A format for events which defines both which events should be included
// and what data should be computed and included for them.
//
// Note that some of the filtering behavior depends on the `TransactionShape`,
// which is expected to be specified alongside usages of `EventFormat`.
type EventFormat struct {
	FiltersByParty MapKV `json:"filtersByParty"`

	// FiltersForAnyParty The union of a set of template filters, interface filters, or a wildcard.
	FiltersForAnyParty *Filters `json:"filtersForAnyParty,omitempty"`

	// Verbose If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
	// In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
	// Optional
	Verbose bool `json:"verbose"`
}

// ExecuteSubmissionResponse defines model for ExecuteSubmissionResponse.
type ExecuteSubmissionResponse = map[string]interface{}

// ExerciseByKeyCommand Exercise a choice on an existing contract specified by its key.
type ExerciseByKeyCommand struct {
	// Choice The name of the choice the client wants to exercise.
	// Must be a valid NameString (as described in ``value.proto``)
	// Required
	Choice string `json:"choice"`

	// ChoiceArgument The argument for this choice.
	// Required
	ChoiceArgument interface{} `json:"choiceArgument"`

	// ContractKey The key of the contract the client wants to exercise upon.
	// Required
	ContractKey interface{} `json:"contractKey"`

	// TemplateId The template of contract the client wants to exercise.
	// Both package-name and package-id reference identifier formats for the template-id are supported.
	// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
	//
	// Required
	TemplateId string `json:"templateId"`
}

// ExerciseCommand Exercise a choice on an existing contract.
type ExerciseCommand struct {
	// Choice The name of the choice the client wants to exercise.
	// Must be a valid NameString (as described in ``value.proto``)
	// Required
	Choice string `json:"choice"`

	// ChoiceArgument The argument for this choice.
	// Required
	ChoiceArgument interface{} `json:"choiceArgument"`

	// ContractId The ID of the contract the client wants to exercise upon.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	ContractId string `json:"contractId"`

	// TemplateId The template of contract the client wants to exercise.
	// Both package-name and package-id reference identifier formats for the template-id are supported.
	// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
	//
	// Required
	TemplateId string `json:"templateId"`
}

// ExercisedEvent Records that a choice has been exercised on a target contract.
type ExercisedEvent struct {
	// ActingParties The parties that exercised the choice.
	// Each element must be a valid PartyIdString (as described in ``value.proto``).
	// Required
	ActingParties *[]string `json:"actingParties,omitempty"`

	// Choice The choice that was exercised on the target contract.
	// Must be a valid NameString (as described in ``value.proto``).
	// Required
	Choice string `json:"choice"`

	// ChoiceArgument The argument of the exercised choice.
	// Required
	ChoiceArgument interface{} `json:"choiceArgument"`

	// Consuming If true, the target contract may no longer be exercised.
	// Required
	Consuming bool `json:"consuming"`

	// ContractId The ID of the target contract.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	ContractId string `json:"contractId"`

	// ExerciseResult The result of exercising the choice.
	// Required
	ExerciseResult interface{} `json:"exerciseResult"`

	// ImplementedInterfaces If the event is consuming, the interfaces implemented by the target template that have been
	// matched from the interface filter query.
	// Populated only in case interface filters with include_interface_view set.
	//
	// The identifier uses the package-id reference format.
	//
	// Optional
	ImplementedInterfaces *[]string `json:"implementedInterfaces,omitempty"`

	// InterfaceId The interface where the choice is defined, if inherited.
	// If defined, the identifier uses the package-id reference format.
	//
	// Optional
	InterfaceId *string `json:"interfaceId,omitempty"`

	// LastDescendantNodeId Specifies the upper boundary of the node ids of the events in the same transaction that appeared as a result of
	// this ``ExercisedEvent``. This allows unambiguous identification of all the members of the subtree rooted at this
	// node. A full subtree can be constructed when all descendant nodes are present in the stream. If nodes are heavily
	// filtered, it is only possible to determine if a node is in a consequent subtree or not.
	// Required
	LastDescendantNodeId int32 `json:"lastDescendantNodeId"`

	// NodeId The position of this event in the originating transaction or reassignment.
	// Node IDs are not necessarily equal across participants,
	// as these may see different projections/parts of transactions.
	// Required, must be valid node ID (non-negative integer)
	NodeId int32 `json:"nodeId"`

	// Offset The offset of origin.
	// Offsets are managed by the participant nodes.
	// Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
	// Required, it is a valid absolute offset (positive integer)
	Offset int64 `json:"offset"`

	// PackageName The package name of the contract.
	// Required
	PackageName string `json:"packageName"`

	// TemplateId The template of the target contract.
	// The identifier uses the package-id reference format.
	//
	// Required
	TemplateId string `json:"templateId"`

	// WitnessParties The parties that are notified of this event. The witnesses of an exercise
	// node will depend on whether the exercise was consuming or not.
	// If consuming, the witnesses are the union of the stakeholders and
	// the actors.
	// If not consuming, the witnesses are the union of the signatories and
	// the actors. Note that the actors might not necessarily be observers
	// and thus signatories. This is the case when the controllers of a
	// choice are specified using "flexible controllers", using the
	// ``choice ... controller`` syntax, and said controllers are not
	// explicitly marked as observers.
	// Each element must be a valid PartyIdString (as described in ``value.proto``).
	// Required
	WitnessParties *[]string `json:"witnessParties,omitempty"`
}

// ExercisedTreeEvent defines model for ExercisedTreeEvent.
type ExercisedTreeEvent struct {
	// Value Records that a choice has been exercised on a target contract.
	Value ExercisedEvent `json:"value"`
}

// ExperimentalCommandInspectionService Whether the Ledger API supports command inspection service
type ExperimentalCommandInspectionService struct {
	Supported bool `json:"supported"`
}

// ExperimentalFeatures See the feature message definitions for descriptions.
type ExperimentalFeatures struct {
	// CommandInspectionService Whether the Ledger API supports command inspection service
	CommandInspectionService *ExperimentalCommandInspectionService `json:"commandInspectionService,omitempty"`

	// StaticTime Ledger is in the static time mode and exposes a time service.
	StaticTime *ExperimentalStaticTime `json:"staticTime,omitempty"`
}

// ExperimentalStaticTime Ledger is in the static time mode and exposes a time service.
type ExperimentalStaticTime struct {
	Supported bool `json:"supported"`
}

// FeaturesDescriptor defines model for FeaturesDescriptor.
type FeaturesDescriptor struct {
	// Experimental See the feature message definitions for descriptions.
	Experimental     *ExperimentalFeatures    `json:"experimental,omitempty"`
	OffsetCheckpoint *OffsetCheckpointFeature `json:"offsetCheckpoint,omitempty"`
	PartyManagement  *PartyManagementFeature  `json:"partyManagement,omitempty"`
	UserManagement   *UserManagementFeature   `json:"userManagement,omitempty"`
}

// FieldMask defines model for FieldMask.
type FieldMask struct {
	Paths         *[]string `json:"paths,omitempty"`
	UnknownFields string    `json:"unknownFields"`
}

// Filters The union of a set of template filters, interface filters, or a wildcard.
type Filters struct {
	// Cumulative Every filter in the cumulative list expands the scope of the resulting stream. Each interface,
	// template or wildcard filter means additional events that will match the query.
	// The impact of include_interface_view and include_created_event_blob fields in the filters will
	// also be accumulated.
	// At least one cumulative filter MUST be specified.
	// A template or an interface SHOULD NOT appear twice in the accumulative field.
	// A wildcard filter SHOULD NOT be defined more than once in the accumulative field.
	// Optional
	Cumulative *[]CumulativeFilter `json:"cumulative,omitempty"`
}

// GetActiveContractsRequest If the given offset is different than the ledger end, and there are (un)assignments in-flight at the given offset,
// the snapshot may fail with "FAILED_PRECONDITION/PARTICIPANT_PRUNED_DATA_ACCESSED".
// Note that it is ok to request acs snapshots for party migration with offsets other than ledger end, because party
// migration is not concerned with incomplete (un)assignments.
type GetActiveContractsRequest struct {
	// ActiveAtOffset The offset at which the snapshot of the active contracts will be computed.
	// Must be no greater than the current ledger end offset.
	// Must be greater than or equal to the last pruning offset.
	// Required, must be a valid absolute offset (positive integer) or ledger begin offset (zero).
	// If zero, the empty set will be returned.
	ActiveAtOffset int64 `json:"activeAtOffset"`

	// EventFormat A format for events which defines both which events should be included
	// and what data should be computed and included for them.
	//
	// Note that some of the filtering behavior depends on the `TransactionShape`,
	// which is expected to be specified alongside usages of `EventFormat`.
	EventFormat *EventFormat `json:"eventFormat,omitempty"`

	// Filter Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// Used both for filtering create and archive events as well as for filtering transaction trees.
	Filter *TransactionFilter `json:"filter,omitempty"`

	// Verbose Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
	// In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
	// Optional, if specified event_format must be unset.
	Verbose bool `json:"verbose"`
}

// GetConnectedSynchronizersResponse defines model for GetConnectedSynchronizersResponse.
type GetConnectedSynchronizersResponse struct {
	ConnectedSynchronizers *[]ConnectedSynchronizer `json:"connectedSynchronizers,omitempty"`
}

// GetEventsByContractIdRequest defines model for GetEventsByContractIdRequest.
type GetEventsByContractIdRequest struct {
	// ContractId The contract id being queried.
	// Required
	ContractId string `json:"contractId"`

	// EventFormat A format for events which defines both which events should be included
	// and what data should be computed and included for them.
	//
	// Note that some of the filtering behavior depends on the `TransactionShape`,
	// which is expected to be specified alongside usages of `EventFormat`.
	EventFormat *EventFormat `json:"eventFormat,omitempty"`

	// RequestingParties Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// The parties whose events the client expects to see.
	// The events associated with the contract id will only be returned if the requesting parties includes
	// at least one party that is a stakeholder of the event. For a definition of stakeholders see
	// https://docs.daml.com/concepts/ledger-model/ledger-privacy.html#contract-observers-and-stakeholders
	// Optional, if some parties specified, event_format needs to be unset.
	RequestingParties *[]string `json:"requestingParties,omitempty"`
}

// GetIdentityProviderConfigResponse defines model for GetIdentityProviderConfigResponse.
type GetIdentityProviderConfigResponse struct {
	IdentityProviderConfig *IdentityProviderConfig `json:"identityProviderConfig,omitempty"`
}

// GetLatestPrunedOffsetsResponse defines model for GetLatestPrunedOffsetsResponse.
type GetLatestPrunedOffsetsResponse struct {
	// AllDivulgedContractsPrunedUpToInclusive It will always be a non-negative integer.
	// If positive, the absolute offset up to which all divulged events have been pruned on the ledger.
	// It can be at or before the ``participant_pruned_up_to_inclusive`` offset.
	// For more details about all divulged events pruning,
	// see ``PruneRequest.prune_all_divulged_contracts`` in ``participant_pruning_service.proto``.
	// If zero, the divulged events have not been pruned yet.
	AllDivulgedContractsPrunedUpToInclusive int64 `json:"allDivulgedContractsPrunedUpToInclusive"`

	// ParticipantPrunedUpToInclusive It will always be a non-negative integer.
	// If positive, the absolute offset up to which the ledger has been pruned,
	// disregarding the state of all divulged contracts pruning.
	// If zero, the ledger has not been pruned yet.
	ParticipantPrunedUpToInclusive int64 `json:"participantPrunedUpToInclusive"`
}

// GetLedgerApiVersionResponse defines model for GetLedgerApiVersionResponse.
type GetLedgerApiVersionResponse struct {
	Features *FeaturesDescriptor `json:"features,omitempty"`

	// Version The version of the ledger API.
	Version string `json:"version"`
}

// GetLedgerEndResponse defines model for GetLedgerEndResponse.
type GetLedgerEndResponse struct {
	// Offset It will always be a non-negative integer.
	// If zero, the participant view of the ledger is empty.
	// If positive, the absolute offset of the ledger as viewed by the participant.
	Offset int64 `json:"offset"`
}

// GetPackageStatusResponse defines model for GetPackageStatusResponse.
type GetPackageStatusResponse struct {
	PackageStatus PackageStatus `json:"packageStatus"`
}

// GetParticipantIdResponse defines model for GetParticipantIdResponse.
type GetParticipantIdResponse struct {
	// ParticipantId Identifier of the participant, which SHOULD be globally unique.
	// Must be a valid LedgerString (as describe in ``value.proto``).
	ParticipantId string `json:"participantId"`
}

// GetPartiesResponse defines model for GetPartiesResponse.
type GetPartiesResponse struct {
	// PartyDetails The details of the requested Daml parties by the participant, if known.
	// The party details may not be in the same order as requested.
	// Required
	PartyDetails *[]PartyDetails `json:"partyDetails,omitempty"`
}

// GetPreferredPackageVersionResponse defines model for GetPreferredPackageVersionResponse.
type GetPreferredPackageVersionResponse struct {
	PackagePreference *PackagePreference `json:"packagePreference,omitempty"`
}

// GetTransactionByIdRequest Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
type GetTransactionByIdRequest struct {
	// RequestingParties Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// The parties whose events the client expects to see.
	// Events that are not visible for the parties in this collection will not be present in the response.
	// Each element must be a valid PartyIdString (as described in ``value.proto``).
	// Must be set for GetTransactionTreeById request.
	// Optional for backwards compatibility for GetTransactionById request: if defined transaction_format must be
	// unset (falling back to defaults).
	RequestingParties *[]string `json:"requestingParties,omitempty"`

	// TransactionFormat A format that specifies what events to include in Daml transactions
	// and what data to compute and include for them.
	TransactionFormat *TransactionFormat `json:"transactionFormat,omitempty"`

	// UpdateId The ID of a particular transaction.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UpdateId string `json:"updateId"`
}

// GetTransactionByOffsetRequest Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
type GetTransactionByOffsetRequest struct {
	// Offset The offset of the transaction being looked up.
	// Must be a valid absolute offset (positive integer).
	// Required
	Offset int64 `json:"offset"`

	// RequestingParties Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// The parties whose events the client expects to see.
	// Events that are not visible for the parties in this collection will not be present in the response.
	// Each element must be a valid PartyIdString (as described in ``value.proto``).
	// Must be set for GetTransactionTreeByOffset request.
	// Optional for backwards compatibility for GetTransactionByOffset request: if defined transaction_format must be
	// unset (falling back to defaults).
	RequestingParties *[]string `json:"requestingParties,omitempty"`

	// TransactionFormat A format that specifies what events to include in Daml transactions
	// and what data to compute and include for them.
	TransactionFormat *TransactionFormat `json:"transactionFormat,omitempty"`
}

// GetUpdateByIdRequest defines model for GetUpdateByIdRequest.
type GetUpdateByIdRequest struct {
	// UpdateFormat A format specifying what updates to include and how to render them.
	UpdateFormat *UpdateFormat `json:"updateFormat,omitempty"`

	// UpdateId The ID of a particular update.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UpdateId string `json:"updateId"`
}

// GetUpdateByOffsetRequest defines model for GetUpdateByOffsetRequest.
type GetUpdateByOffsetRequest struct {
	// Offset The offset of the update being looked up.
	// Must be a valid absolute offset (positive integer).
	// Required
	Offset int64 `json:"offset"`

	// UpdateFormat A format specifying what updates to include and how to render them.
	UpdateFormat *UpdateFormat `json:"updateFormat,omitempty"`
}

// GetUpdatesRequest defines model for GetUpdatesRequest.
type GetUpdatesRequest struct {
	// BeginExclusive Beginning of the requested ledger section (non-negative integer).
	// The response will only contain transactions whose offset is strictly greater than this.
	// If zero, the stream will start from the beginning of the ledger.
	// If positive, the streaming will start after this absolute offset.
	// If the ledger has been pruned, this parameter must be specified and be greater than the pruning offset.
	BeginExclusive int64 `json:"beginExclusive"`

	// EndInclusive End of the requested ledger section.
	// The response will only contain transactions whose offset is less than or equal to this.
	// Optional, if empty, the stream will not terminate.
	// If specified, the stream will terminate after this absolute offset (positive integer) is reached.
	EndInclusive *int64 `json:"endInclusive,omitempty"`

	// Filter Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// Used both for filtering create and archive events as well as for filtering transaction trees.
	Filter *TransactionFilter `json:"filter,omitempty"`

	// UpdateFormat A format specifying what updates to include and how to render them.
	UpdateFormat *UpdateFormat `json:"updateFormat,omitempty"`

	// Verbose Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
	// In particular, setting the verbose flag to true triggers the ledger to include labels, record and variant type ids
	// for record fields.
	// Optional for backwards compatibility, if defined update_format must be unset
	Verbose bool `json:"verbose"`
}

// GetUserResponse defines model for GetUserResponse.
type GetUserResponse struct {
	// User  Users and rights
	// /////////////////
	//  Users are used to dynamically manage the rights given to Daml applications.
	//  They are stored and managed per participant node.
	User *User `json:"user,omitempty"`
}

// GrantUserRightsRequest Add the rights to the set of rights granted to the user.
//
// Required authorization: “HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)“
type GrantUserRightsRequest struct {
	// IdentityProviderId The id of the ``Identity Provider``
	// Optional, if not set, assume the user is managed by the default identity provider.
	IdentityProviderId string `json:"identityProviderId"`

	// Rights The rights to grant.
	// Optional
	Rights *[]Right `json:"rights,omitempty"`

	// UserId The user to whom to grant rights.
	// Required
	UserId string `json:"userId"`
}

// GrantUserRightsResponse defines model for GrantUserRightsResponse.
type GrantUserRightsResponse struct {
	// NewlyGrantedRights The rights that were newly granted by the request.
	NewlyGrantedRights *[]Right `json:"newlyGrantedRights,omitempty"`
}

// HASHINGSCHEMEVERSIONUNSPECIFIED defines model for HASHING_SCHEME_VERSION_UNSPECIFIED.
type HASHINGSCHEMEVERSIONUNSPECIFIED = map[string]interface{}

// HASHINGSCHEMEVERSIONV2 defines model for HASHING_SCHEME_VERSION_V2.
type HASHINGSCHEMEVERSIONV2 = map[string]interface{}

// HashingSchemeVersion defines model for HashingSchemeVersion.
type HashingSchemeVersion struct {
	union json.RawMessage
}

// HashingSchemeVersion0 defines model for .
type HashingSchemeVersion0 struct {
	HASHINGSCHEMEVERSIONUNSPECIFIED HASHINGSCHEMEVERSIONUNSPECIFIED `json:"HASHING_SCHEME_VERSION_UNSPECIFIED"`
}

// HashingSchemeVersion1 defines model for .
type HashingSchemeVersion1 struct {
	HASHINGSCHEMEVERSIONV2 HASHINGSCHEMEVERSIONV2 `json:"HASHING_SCHEME_VERSION_V2"`
}

// HashingSchemeVersion2 defines model for .
type HashingSchemeVersion2 struct {
	Recognized Recognized2 `json:"Recognized"`
}

// HashingSchemeVersion3 defines model for .
type HashingSchemeVersion3 struct {
	Unrecognized Unrecognized3 `json:"Unrecognized"`
}

// Identifier defines model for Identifier.
type Identifier struct {
	EntityName string `json:"entityName"`
	ModuleName string `json:"moduleName"`
	PackageId  string `json:"packageId"`
}

// IdentifierFilter defines model for IdentifierFilter.
type IdentifierFilter struct {
	union json.RawMessage
}

// IdentifierFilter0 defines model for .
type IdentifierFilter0 struct {
	Empty Empty1 `json:"Empty"`
}

// IdentifierFilter1 defines model for .
type IdentifierFilter1 struct {
	// InterfaceFilter This filter matches contracts that implement a specific interface.
	InterfaceFilter InterfaceFilter `json:"InterfaceFilter"`
}

// IdentifierFilter2 defines model for .
type IdentifierFilter2 struct {
	// TemplateFilter This filter matches contracts of a specific template.
	TemplateFilter TemplateFilter `json:"TemplateFilter"`
}

// IdentifierFilter3 defines model for .
type IdentifierFilter3 struct {
	// WildcardFilter This filter matches all templates.
	WildcardFilter WildcardFilter `json:"WildcardFilter"`
}

// IdentityProviderAdmin defines model for IdentityProviderAdmin.
type IdentityProviderAdmin struct {
	Value IdentityProviderAdmin1 `json:"value"`
}

// IdentityProviderAdmin1 defines model for IdentityProviderAdmin1.
type IdentityProviderAdmin1 = map[string]interface{}

// IdentityProviderConfig defines model for IdentityProviderConfig.
type IdentityProviderConfig struct {
	// Audience Specifies the audience of the JWT token.
	// When set, the callers using JWT tokens issued by this identity provider are allowed to get an access
	// only if the "aud" claim includes the string specified here
	// Optional,
	// Modifiable
	Audience string `json:"audience"`

	// IdentityProviderId The identity provider identifier
	// Must be a valid LedgerString (as describe in ``value.proto``).
	// Required
	IdentityProviderId string `json:"identityProviderId"`

	// IsDeactivated When set, the callers using JWT tokens issued by this identity provider are denied all access
	// to the Ledger API.
	// Optional,
	// Modifiable
	IsDeactivated bool `json:"isDeactivated"`

	// Issuer Specifies the issuer of the JWT token.
	// The issuer value is a case sensitive URL using the https scheme that contains scheme, host,
	// and optionally, port number and path components and no query or fragment components.
	// Required
	// Modifiable
	Issuer string `json:"issuer"`

	// JwksUrl The JWKS (JSON Web Key Set) URL.
	// The Ledger API uses JWKs (JSON Web Keys) from the provided URL to verify that the JWT has been
	// signed with the loaded JWK. Only RS256 (RSA Signature with SHA-256) signing algorithm is supported.
	// Required
	// Modifiable
	JwksUrl string `json:"jwksUrl"`
}

// InterfaceFilter This filter matches contracts that implement a specific interface.
type InterfaceFilter struct {
	// Value This filter matches contracts that implement a specific interface.
	Value InterfaceFilter1 `json:"value"`
}

// InterfaceFilter1 This filter matches contracts that implement a specific interface.
type InterfaceFilter1 struct {
	// IncludeCreatedEventBlob Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
	// Use this to access the contract create event payload in your API client
	// for submitting it as a disclosed contract with future commands.
	// Optional
	IncludeCreatedEventBlob bool `json:"includeCreatedEventBlob"`

	// IncludeInterfaceView Whether to include the interface view on the contract in the returned ``CreatedEvent``.
	// Use this to access contract data in a uniform manner in your API client.
	// Optional
	IncludeInterfaceView bool `json:"includeInterfaceView"`

	// InterfaceId The interface that a matching contract must implement.
	// The ``interface_id`` needs to be valid: corresponding interface should be defined in
	// one of the available packages at the time of the query.
	// Both package-name and package-id reference formats for the identifier are supported.
	// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
	//
	// Required
	InterfaceId *string `json:"interfaceId,omitempty"`
}

// JsActiveContract defines model for JsActiveContract.
type JsActiveContract struct {
	// CreatedEvent Records that a contract has been created, and choices may now be exercised on it.
	CreatedEvent CreatedEvent `json:"createdEvent"`

	// ReassignmentCounter Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
	// with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
	// equals zero.
	// This field will be the reassignment_counter of the latest observable activation event on this synchronizer, which is
	// before the active_at_offset.
	// Required
	ReassignmentCounter int64 `json:"reassignmentCounter"`

	// SynchronizerId A valid synchronizer id
	// Required
	SynchronizerId string `json:"synchronizerId"`
}

// JsArchived defines model for JsArchived.
type JsArchived struct {
	// ArchivedEvent Records that a contract has been archived, and choices may no longer be exercised on it.
	ArchivedEvent ArchivedEvent `json:"archivedEvent"`

	// SynchronizerId Required
	// The synchronizer which sequenced the archival of the contract
	SynchronizerId string `json:"synchronizerId"`
}

// JsAssignedEvent Records that a contract has been assigned, and it can be used on the target synchronizer.
type JsAssignedEvent struct {
	// CreatedEvent Records that a contract has been created, and choices may now be exercised on it.
	CreatedEvent CreatedEvent `json:"createdEvent"`

	// ReassignmentCounter Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
	// with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
	// equals zero.
	// Required
	ReassignmentCounter int64 `json:"reassignmentCounter"`

	// Source The ID of the source synchronizer.
	// Must be a valid synchronizer id.
	// Required
	Source string `json:"source"`

	// Submitter Party on whose behalf the assign command was executed.
	// Empty if the assignment happened offline via the repair service.
	// Must be a valid PartyIdString (as described in ``value.proto``).
	// Optional
	Submitter string `json:"submitter"`

	// Target The ID of the target synchronizer.
	// Must be a valid synchronizer id.
	// Required
	Target string `json:"target"`

	// UnassignId The ID from the unassigned event.
	// For correlation capabilities.
	// For one contract the (unassign_id, source synchronizer) pair is unique.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UnassignId string `json:"unassignId"`
}

// JsAssignmentEvent defines model for JsAssignmentEvent.
type JsAssignmentEvent struct {
	// CreatedEvent Records that a contract has been created, and choices may now be exercised on it.
	CreatedEvent        CreatedEvent `json:"createdEvent"`
	ReassignmentCounter int64        `json:"reassignmentCounter"`
	Source              string       `json:"source"`
	Submitter           string       `json:"submitter"`
	Target              string       `json:"target"`
	UnassignId          string       `json:"unassignId"`
}

// JsCantonError defines model for JsCantonError.
type JsCantonError struct {
	Cause          string                `json:"cause"`
	Code           string                `json:"code"`
	Context        MapString             `json:"context"`
	CorrelationId  *string               `json:"correlationId,omitempty"`
	DefiniteAnswer *bool                 `json:"definiteAnswer,omitempty"`
	ErrorCategory  int32                 `json:"errorCategory"`
	GrpcCodeValue  *int32                `json:"grpcCodeValue,omitempty"`
	Resources      *[]Tuple2StringString `json:"resources,omitempty"`
	RetryInfo      *string               `json:"retryInfo,omitempty"`
	TraceId        *string               `json:"traceId,omitempty"`
}

// JsCommands A composite command that groups multiple commands together.
type JsCommands struct {
	// ActAs Set of parties on whose behalf the command should be executed.
	// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
	// to act on behalf of each of the given parties.
	// Each element must be a valid PartyIdString (as described in ``value.proto``).
	// Required, must be non-empty.
	ActAs *[]string `json:"actAs,omitempty"`

	// CommandId Uniquely identifies the command.
	// The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
	// where act_as is interpreted as a set of party names.
	// The change ID can be used for matching the intended ledger changes with all their completions.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	CommandId string `json:"commandId"`

	// Commands Individual elements of this atomic command. Must be non-empty.
	// Required
	Commands *[]Command `json:"commands,omitempty"`

	// DeduplicationPeriod Specifies the deduplication period for the change ID.
	// If omitted, the participant will assume the configured maximum deduplication time.
	DeduplicationPeriod *DeduplicationPeriod `json:"deduplicationPeriod,omitempty"`

	// DisclosedContracts Additional contracts used to resolve contract & contract key lookups.
	// Optional
	DisclosedContracts *[]DisclosedContract `json:"disclosedContracts,omitempty"`

	// MinLedgerTimeAbs Lower bound for the ledger time assigned to the resulting transaction.
	// Note: The ledger time of a transaction is assigned as part of command interpretation.
	// Use this property if you expect that command interpretation will take a considerate amount of time, such that by
	// the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore.
	// Must not be set at the same time as min_ledger_time_rel.
	// Optional
	MinLedgerTimeAbs *string   `json:"minLedgerTimeAbs,omitempty"`
	MinLedgerTimeRel *Duration `json:"minLedgerTimeRel,omitempty"`

	// PackageIdSelectionPreference The package-id selection preference of the client for resolving
	// package names and interface instances in command submission and interpretation
	PackageIdSelectionPreference *[]string `json:"packageIdSelectionPreference,omitempty"`

	// ReadAs Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
	// This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
	// Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant
	// node is only visible to a subset of these parties. A command can only use contracts that are visible to at least
	// one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
	// rules for fetch operations.
	// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
	// to read contract data on behalf of each of the given parties.
	// Optional
	ReadAs *[]string `json:"readAs,omitempty"`

	// SubmissionId A unique identifier to distinguish completions for different submissions with the same change ID.
	// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
	// with the same change ID.
	// Must be a valid LedgerString (as described in ``value.proto``).
	//
	// If omitted, the participant or the committer may set a value of their choice.
	// Optional
	SubmissionId *string `json:"submissionId,omitempty"`

	// SynchronizerId Must be a valid synchronizer id
	// Optional
	SynchronizerId *string `json:"synchronizerId,omitempty"`

	// UserId Uniquely identifies the participant user that issued the command.
	// Must be a valid UserIdString (as described in ``value.proto``).
	// Required unless authentication is used with a user token.
	// In that case, the token's user-id will be used for the request's user_id.
	UserId *string `json:"userId,omitempty"`

	// WorkflowId Identifier of the on-ledger workflow that this command is a part of.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	WorkflowId *string `json:"workflowId,omitempty"`
}

// JsContractEntry For a contract there could be multiple contract_entry-s in the entire snapshot. These together define
// the state of one contract in the snapshot.
// A contract_entry is included in the result, if and only if there is at least one stakeholder party of the contract
// that is hosted on the synchronizer at the time of the event and the party satisfies the
// “TransactionFilter“ in the query.
type JsContractEntry struct {
	union json.RawMessage
}

// JsContractEntry0 defines model for .
type JsContractEntry0 struct {
	JsActiveContract JsActiveContract `json:"JsActiveContract"`
}

// JsContractEntry1 defines model for .
type JsContractEntry1 struct {
	JsEmpty JsEmpty `json:"JsEmpty"`
}

// JsContractEntry2 defines model for .
type JsContractEntry2 struct {
	JsIncompleteAssigned JsIncompleteAssigned `json:"JsIncompleteAssigned"`
}

// JsContractEntry3 defines model for .
type JsContractEntry3 struct {
	JsIncompleteUnassigned JsIncompleteUnassigned `json:"JsIncompleteUnassigned"`
}

// JsCreated defines model for JsCreated.
type JsCreated struct {
	// CreatedEvent Records that a contract has been created, and choices may now be exercised on it.
	CreatedEvent CreatedEvent `json:"createdEvent"`

	// SynchronizerId The synchronizer which sequenced the creation of the contract
	// Required
	SynchronizerId string `json:"synchronizerId"`
}

// JsEmpty defines model for JsEmpty.
type JsEmpty = map[string]interface{}

// JsExecuteSubmissionRequest defines model for JsExecuteSubmissionRequest.
type JsExecuteSubmissionRequest struct {
	// TransactionDeduplicationPeriod Specifies the deduplication period for the change ID.
	// If omitted, the participant will assume the configured maximum deduplication time.
	TransactionDeduplicationPeriod TransactionDeduplicationPeriod `json:"deduplicationPeriod"`
	HashingSchemeVersion           HashingSchemeVersion           `json:"hashingSchemeVersion"`

	// PartySignatures Additional signatures provided by the submitting parties
	PartySignatures *PartySignatures `json:"partySignatures,omitempty"`

	// PreparedTransaction the prepared transaction
	// Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
	// obtained from calling `prepareSubmission`.
	PreparedTransaction *string `json:"preparedTransaction,omitempty"`

	// SubmissionId A unique identifier to distinguish completions for different submissions with the same change ID.
	// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
	// with the same change ID.
	// Must be a valid LedgerString (as described in ``value.proto``).
	//
	// Required
	SubmissionId string `json:"submissionId"`

	// UserId See [PrepareSubmissionRequest.user_id]
	UserId string `json:"userId"`
}

// JsGetActiveContractsResponse defines model for JsGetActiveContractsResponse.
type JsGetActiveContractsResponse struct {
	// ContractEntry For a contract there could be multiple contract_entry-s in the entire snapshot. These together define
	// the state of one contract in the snapshot.
	// A contract_entry is included in the result, if and only if there is at least one stakeholder party of the contract
	// that is hosted on the synchronizer at the time of the event and the party satisfies the
	// ``TransactionFilter`` in the query.
	ContractEntry JsContractEntry `json:"contractEntry"`

	// WorkflowId The workflow ID used in command submission which corresponds to the contract_entry. Only set if
	// the ``workflow_id`` for the command was set.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	WorkflowId string `json:"workflowId"`
}

// JsGetEventsByContractIdResponse defines model for JsGetEventsByContractIdResponse.
type JsGetEventsByContractIdResponse struct {
	Archived *JsArchived `json:"archived,omitempty"`
	Created  *JsCreated  `json:"created,omitempty"`
}

// JsGetTransactionResponse Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
type JsGetTransactionResponse struct {
	// Transaction Filtered view of an on-ledger transaction's create and archive events.
	Transaction JsTransaction `json:"transaction"`
}

// JsGetTransactionTreeResponse Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
type JsGetTransactionTreeResponse struct {
	// Transaction Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// Complete view of an on-ledger transaction.
	Transaction JsTransactionTree `json:"transaction"`
}

// JsGetUpdateResponse defines model for JsGetUpdateResponse.
type JsGetUpdateResponse struct {
	// Update The update that matches the filter in the request.
	Update Update `json:"update"`
}

// JsGetUpdateTreesResponse Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
type JsGetUpdateTreesResponse struct {
	// UpdateUnion The update that matches the filter in the request.
	UpdateUnion UpdateUnion `json:"update"`
}

// JsGetUpdatesResponse defines model for JsGetUpdatesResponse.
type JsGetUpdatesResponse struct {
	// Update The update that matches the filter in the request.
	Update Update `json:"update"`
}

// JsIncompleteAssigned defines model for JsIncompleteAssigned.
type JsIncompleteAssigned struct {
	// AssignedEvent Records that a contract has been assigned, and it can be used on the target synchronizer.
	AssignedEvent JsAssignedEvent `json:"assignedEvent"`
}

// JsIncompleteUnassigned defines model for JsIncompleteUnassigned.
type JsIncompleteUnassigned struct {
	// CreatedEvent Records that a contract has been created, and choices may now be exercised on it.
	CreatedEvent CreatedEvent `json:"createdEvent"`

	// UnassignedEvent Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
	UnassignedEvent UnassignedEvent `json:"unassignedEvent"`
}

// JsInterfaceView View of a create event matched by an interface filter.
type JsInterfaceView struct {
	// InterfaceId The interface implemented by the matched event.
	// The identifier uses the package-id reference format.
	//
	// Required
	InterfaceId string   `json:"interfaceId"`
	ViewStatus  JsStatus `json:"viewStatus"`

	// ViewValue The value of the interface's view method on this event.
	// Set if it was requested in the ``InterfaceFilter`` and it could be
	// sucessfully computed.
	// Optional
	ViewValue interface{} `json:"viewValue,omitempty"`
}

// JsPrepareSubmissionRequest defines model for JsPrepareSubmissionRequest.
type JsPrepareSubmissionRequest struct {
	// ActAs Set of parties on whose behalf the command should be executed, if submitted.
	// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
	// to **read** (not act) on behalf of each of the given parties. This is because this RPC merely prepares a transaction
	// and does not execute it. Therefore read authorization is sufficient even for actAs parties.
	// Note: This may change, and more specific authorization scope may be introduced in the future.
	// Each element must be a valid PartyIdString (as described in ``value.proto``).
	// Required, must be non-empty.
	ActAs *[]string `json:"actAs,omitempty"`

	// CommandId Uniquely identifies the command.
	// The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
	// where act_as is interpreted as a set of party names.
	// The change ID can be used for matching the intended ledger changes with all their completions.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	CommandId string `json:"commandId"`

	// Commands Individual elements of this atomic command. Must be non-empty.
	// Required
	Commands *[]Command `json:"commands,omitempty"`

	// DisclosedContracts Additional contracts used to resolve contract & contract key lookups.
	// Optional
	DisclosedContracts *[]DisclosedContract `json:"disclosedContracts,omitempty"`
	MinLedgerTime      *MinLedgerTime       `json:"minLedgerTime,omitempty"`

	// PackageIdSelectionPreference The package-id selection preference of the client for resolving
	// package names and interface instances in command submission and interpretation
	PackageIdSelectionPreference *[]string `json:"packageIdSelectionPreference,omitempty"`

	// ReadAs Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
	// This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
	// Note: A command can only use contracts that are visible to at least
	// one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
	// rules for fetch operations.
	// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
	// to read contract data on behalf of each of the given parties.
	// Optional
	ReadAs *[]string `json:"readAs,omitempty"`

	// SynchronizerId Must be a valid synchronizer id
	// Required
	SynchronizerId string `json:"synchronizerId"`

	// UserId Uniquely identifies the participant user that prepares the transaction.
	// Must be a valid UserIdString (as described in ``value.proto``).
	// Required unless authentication is used with a user token.
	// In that case, the token's user-id will be used for the request's user_id.
	UserId string `json:"userId"`

	// VerboseHashing When true, the response will contain additional details on how the transaction was encoded and hashed
	// This can be useful for troubleshooting of hash mismatches. Should only be used for debugging.
	VerboseHashing bool `json:"verboseHashing"`
}

// JsPrepareSubmissionResponse [docs-entry-end: HashingSchemeVersion]
type JsPrepareSubmissionResponse struct {
	// HashingDetails Optional additional details on how the transaction was encoded and hashed. Only set if verbose_hashing = true in the request
	// Note that there are no guarantees on the stability of the format or content of this field.
	// Its content should NOT be parsed and should only be used for troubleshooting purposes.
	HashingDetails       *string              `json:"hashingDetails,omitempty"`
	HashingSchemeVersion HashingSchemeVersion `json:"hashingSchemeVersion"`

	// PreparedTransaction The interpreted transaction, it represents the ledger changes necessary to execute the commands specified in the request.
	// Clients MUST display the content of the transaction to the user for them to validate before signing the hash if the preparing participant is not trusted.
	PreparedTransaction *string `json:"preparedTransaction,omitempty"`

	// PreparedTransactionHash Hash of the transaction, this is what needs to be signed by the party to authorize the transaction.
	// Only provided for convenience, clients MUST recompute the hash from the raw transaction if the preparing participant is not trusted.
	// May be removed in future versions
	PreparedTransactionHash string `json:"preparedTransactionHash"`
}

// JsReassignment Complete view of an on-ledger reassignment.
type JsReassignment struct {
	// CommandId The ID of the command which resulted in this reassignment. Missing for everyone except the submitting party on the submitting participant.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	CommandId string `json:"commandId"`

	// Events The collection of reassignment events. Required.
	Events *[]JsReassignmentEvent `json:"events,omitempty"`

	// Offset The participant's offset. The details of this field are described in ``community/ledger-api/README.md``.
	// Required, must be a valid absolute offset (positive integer).
	Offset int64 `json:"offset"`

	// RecordTime The time at which the reassignment was recorded. The record time refers to the source/target
	// synchronizer for an unassign/assign event respectively.
	// Required
	RecordTime   string        `json:"recordTime"`
	TraceContext *TraceContext `json:"traceContext,omitempty"`

	// UpdateId Assigned by the server. Useful for correlating logs.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UpdateId string `json:"updateId"`

	// WorkflowId The workflow ID used in reassignment command submission. Only set if the ``workflow_id`` for the command was set.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	WorkflowId string `json:"workflowId"`
}

// JsReassignmentEvent defines model for JsReassignmentEvent.
type JsReassignmentEvent struct {
	union json.RawMessage
}

// JsStatus defines model for JsStatus.
type JsStatus struct {
	Code          int32   `json:"code"`
	Details       *[]Any  `json:"details,omitempty"`
	Message       string  `json:"message"`
	UnknownFields *string `json:"unknownFields,omitempty"`
}

// JsSubmitAndWaitForReassignmentResponse defines model for JsSubmitAndWaitForReassignmentResponse.
type JsSubmitAndWaitForReassignmentResponse struct {
	// Reassignment Complete view of an on-ledger reassignment.
	Reassignment JsReassignment `json:"reassignment"`
}

// JsSubmitAndWaitForTransactionRequest These commands are executed as a single atomic transaction.
type JsSubmitAndWaitForTransactionRequest struct {
	// Commands A composite command that groups multiple commands together.
	Commands JsCommands `json:"commands"`

	// TransactionFormat A format that specifies what events to include in Daml transactions
	// and what data to compute and include for them.
	TransactionFormat TransactionFormat `json:"transactionFormat"`
}

// JsSubmitAndWaitForTransactionResponse defines model for JsSubmitAndWaitForTransactionResponse.
type JsSubmitAndWaitForTransactionResponse struct {
	// Transaction Filtered view of an on-ledger transaction's create and archive events.
	Transaction JsTransaction `json:"transaction"`
}

// JsSubmitAndWaitForTransactionTreeResponse Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
type JsSubmitAndWaitForTransactionTreeResponse struct {
	// TransactionTree Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// Complete view of an on-ledger transaction.
	TransactionTree JsTransactionTree `json:"transactionTree"`
}

// JsTopologyTransaction defines model for JsTopologyTransaction.
type JsTopologyTransaction struct {
	// Events A non-empty list of topology events.
	// Required
	Events *[]ParticipantEvent `json:"events,omitempty"`

	// Offset The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
	// Required, it is a valid absolute offset (positive integer).
	Offset int64 `json:"offset"`

	// RecordTime The time at which the changes in the topology transaction become effective. There is a small delay between a
	// topology transaction being sequenced and the changes it contains becoming effective. Topology transactions appear
	// in order relative to a synchronizer based on their effective time rather than their sequencing time.
	// Required
	RecordTime string `json:"recordTime"`

	// SynchronizerId A valid synchronizer id.
	// Identifies the synchronizer that synchronized the topology transaction.
	// Required
	SynchronizerId string        `json:"synchronizerId"`
	TraceContext   *TraceContext `json:"traceContext,omitempty"`

	// UpdateId Assigned by the server. Useful for correlating logs.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UpdateId string `json:"updateId"`
}

// JsTransaction Filtered view of an on-ledger transaction's create and archive events.
type JsTransaction struct {
	// CommandId The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	CommandId string `json:"commandId"`

	// EffectiveAt Ledger effective time.
	// Required
	EffectiveAt string `json:"effectiveAt"`

	// Events The collection of events.
	// Contains:
	//
	// - ``CreatedEvent`` or ``ArchivedEvent`` in case of ACS_DELTA transaction shape
	// - ``CreatedEvent`` or ``ExercisedEvent`` in case of LEDGER_EFFECTS transaction shape
	//
	// Required
	Events *[]Event `json:"events,omitempty"`

	// Offset The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
	// Required, it is a valid absolute offset (positive integer).
	Offset int64 `json:"offset"`

	// RecordTime The time at which the transaction was recorded. The record time refers to the synchronizer
	// which synchronized the transaction.
	// Required
	RecordTime string `json:"recordTime"`

	// SynchronizerId A valid synchronizer id.
	// Identifies the synchronizer that synchronized the transaction.
	// Required
	SynchronizerId string        `json:"synchronizerId"`
	TraceContext   *TraceContext `json:"traceContext,omitempty"`

	// UpdateId Assigned by the server. Useful for correlating logs.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UpdateId string `json:"updateId"`

	// WorkflowId The workflow ID used in command submission.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	WorkflowId string `json:"workflowId"`
}

// JsTransactionTree Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
// Complete view of an on-ledger transaction.
type JsTransactionTree struct {
	// CommandId The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	CommandId string `json:"commandId"`

	// EffectiveAt Ledger effective time.
	// Required
	EffectiveAt *string `json:"effectiveAt,omitempty"`
	EventsById  MapKV   `json:"eventsById"`

	// Offset The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
	// Required, it is a valid absolute offset (positive integer).
	Offset int64 `json:"offset"`

	// RecordTime The time at which the transaction was recorded. The record time refers to the synchronizer
	// which synchronized the transaction.
	// Required
	RecordTime string `json:"recordTime"`

	// SynchronizerId A valid synchronizer id.
	// Identifies the synchronizer that synchronized the transaction.
	// Required
	SynchronizerId string        `json:"synchronizerId"`
	TraceContext   *TraceContext `json:"traceContext,omitempty"`

	// UpdateId Assigned by the server. Useful for correlating logs.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UpdateId string `json:"updateId"`

	// WorkflowId The workflow ID used in command submission. Only set if the ``workflow_id`` for the command was set.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	WorkflowId string `json:"workflowId"`
}

// JsUnassignedEvent Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
type JsUnassignedEvent struct {
	// Value Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
	Value UnassignedEvent `json:"value"`
}

// Kind defines model for Kind.
type Kind struct {
	union json.RawMessage
}

// Kind0 defines model for .
type Kind0 struct {
	CanActAs CanActAs `json:"CanActAs"`
}

// Kind1 defines model for .
type Kind1 struct {
	CanReadAs CanReadAs `json:"CanReadAs"`
}

// Kind2 defines model for .
type Kind2 struct {
	CanReadAsAnyParty CanReadAsAnyParty `json:"CanReadAsAnyParty"`
}

// Kind3 defines model for .
type Kind3 struct {
	Empty Empty5 `json:"Empty"`
}

// Kind4 defines model for .
type Kind4 struct {
	IdentityProviderAdmin IdentityProviderAdmin `json:"IdentityProviderAdmin"`
}

// Kind5 defines model for .
type Kind5 struct {
	ParticipantAdmin ParticipantAdmin `json:"ParticipantAdmin"`
}

// ListIdentityProviderConfigsResponse defines model for ListIdentityProviderConfigsResponse.
type ListIdentityProviderConfigsResponse struct {
	IdentityProviderConfigs *[]IdentityProviderConfig `json:"identityProviderConfigs,omitempty"`
}

// ListKnownPartiesResponse defines model for ListKnownPartiesResponse.
type ListKnownPartiesResponse struct {
	// NextPageToken Pagination token to retrieve the next page.
	// Empty, if there are no further results.
	NextPageToken string `json:"nextPageToken"`

	// PartyDetails The details of all Daml parties known by the participant.
	// Required
	PartyDetails *[]PartyDetails `json:"partyDetails,omitempty"`
}

// ListPackagesResponse defines model for ListPackagesResponse.
type ListPackagesResponse struct {
	// PackageIds The IDs of all Daml-LF packages supported by the server.
	// Each element must be a valid PackageIdString (as described in ``value.proto``).
	// Required
	PackageIds *[]string `json:"packageIds,omitempty"`
}

// ListUserRightsResponse defines model for ListUserRightsResponse.
type ListUserRightsResponse struct {
	// Rights All rights of the user.
	Rights *[]Right `json:"rights,omitempty"`
}

// ListUsersResponse defines model for ListUsersResponse.
type ListUsersResponse struct {
	// NextPageToken Pagination token to retrieve the next page.
	// Empty, if there are no further results.
	NextPageToken string `json:"nextPageToken"`

	// Users A subset of users of the participant node that fit into this page.
	Users *[]User `json:"users,omitempty"`
}

// MapFilters defines model for Map_Filters.
type MapFilters map[string]Filters

// MapKV defines model for Map_K_V.
type MapKV map[string]Filters

// MapString defines model for Map_String.
type MapString map[string]string

// MinLedgerTime defines model for MinLedgerTime.
type MinLedgerTime struct {
	Time Time `json:"time"`
}

// MinLedgerTimeAbs defines model for MinLedgerTimeAbs.
type MinLedgerTimeAbs struct {
	Value string `json:"value"`
}

// MinLedgerTimeRel defines model for MinLedgerTimeRel.
type MinLedgerTimeRel struct {
	Value Duration `json:"value"`
}

// ObjectMeta Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
//
// Based on “ObjectMeta“ meta used in Kubernetes API.
// See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640
type ObjectMeta struct {
	Annotations MapString `json:"annotations"`

	// ResourceVersion An opaque, non-empty value, populated by a participant server which represents the internal version of the resource
	// this ``ObjectMeta`` message is attached to. The participant server will change it to a unique value each time the corresponding resource is updated.
	// You must not rely on the format of resource version. The participant server might change it without notice.
	// You can obtain the newest resource version value by issuing a read request.
	// You may use it for concurrent change detection by passing it back unmodified in an update request.
	// The participant server will then compare the passed value with the value maintained by the system to determine
	// if any other updates took place since you had read the resource version.
	// Upon a successful update you are guaranteed that no other update took place during your read-modify-write sequence.
	// However, if another update took place during your read-modify-write sequence then your update will fail with an appropriate error.
	// Concurrent change control is optional. It will be applied only if you include a resource version in an update request.
	// When creating a new instance of a resource you must leave the resource version empty.
	// Its value will be populated by the participant server upon successful resource creation.
	// Optional
	ResourceVersion string `json:"resourceVersion"`
}

// OffsetCheckpoint OffsetCheckpoints may be used to:
//
// - detect time out of commands.
// - provide an offset which can be used to restart consumption.
type OffsetCheckpoint struct {
	// Value OffsetCheckpoints may be used to:
	//
	// - detect time out of commands.
	// - provide an offset which can be used to restart consumption.
	Value OffsetCheckpoint1 `json:"value"`
}

// OffsetCheckpoint1 OffsetCheckpoints may be used to:
//
// - detect time out of commands.
// - provide an offset which can be used to restart consumption.
type OffsetCheckpoint1 struct {
	// Offset The participant's offset, the details of the offset field are described in ``community/ledger-api/README.md``.
	// Required, must be a valid absolute offset (positive integer).
	Offset            int64               `json:"offset"`
	SynchronizerTimes *[]SynchronizerTime `json:"synchronizerTimes,omitempty"`
}

// OffsetCheckpoint2 OffsetCheckpoints may be used to:
//
// - detect time out of commands.
// - provide an offset which can be used to restart consumption.
type OffsetCheckpoint2 struct {
	// Value OffsetCheckpoints may be used to:
	//
	// - detect time out of commands.
	// - provide an offset which can be used to restart consumption.
	Value OffsetCheckpoint1 `json:"value"`
}

// OffsetCheckpoint3 OffsetCheckpoints may be used to:
//
// - detect time out of commands.
// - provide an offset which can be used to restart consumption.
type OffsetCheckpoint3 struct {
	// Value OffsetCheckpoints may be used to:
	//
	// - detect time out of commands.
	// - provide an offset which can be used to restart consumption.
	Value OffsetCheckpoint1 `json:"value"`
}

// OffsetCheckpointFeature defines model for OffsetCheckpointFeature.
type OffsetCheckpointFeature struct {
	MaxOffsetCheckpointEmissionDelay *Duration `json:"maxOffsetCheckpointEmissionDelay,omitempty"`
}

// PACKAGESTATUSREGISTERED defines model for PACKAGE_STATUS_REGISTERED.
type PACKAGESTATUSREGISTERED = map[string]interface{}

// PACKAGESTATUSUNSPECIFIED defines model for PACKAGE_STATUS_UNSPECIFIED.
type PACKAGESTATUSUNSPECIFIED = map[string]interface{}

// PARTICIPANTPERMISSIONCONFIRMATION defines model for PARTICIPANT_PERMISSION_CONFIRMATION.
type PARTICIPANTPERMISSIONCONFIRMATION = map[string]interface{}

// PARTICIPANTPERMISSIONOBSERVATION defines model for PARTICIPANT_PERMISSION_OBSERVATION.
type PARTICIPANTPERMISSIONOBSERVATION = map[string]interface{}

// PARTICIPANTPERMISSIONSUBMISSION defines model for PARTICIPANT_PERMISSION_SUBMISSION.
type PARTICIPANTPERMISSIONSUBMISSION = map[string]interface{}

// PARTICIPANTPERMISSIONUNSPECIFIED defines model for PARTICIPANT_PERMISSION_UNSPECIFIED.
type PARTICIPANTPERMISSIONUNSPECIFIED = map[string]interface{}

// PackagePreference defines model for PackagePreference.
type PackagePreference struct {
	PackageReference *PackageReference `json:"packageReference,omitempty"`

	// SynchronizerId The synchronizer for which the preferred package was computed.
	// If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
	// Required
	SynchronizerId string `json:"synchronizerId"`
}

// PackageReference defines model for PackageReference.
type PackageReference struct {
	// PackageId Required
	PackageId string `json:"packageId"`

	// PackageName Required
	PackageName string `json:"packageName"`

	// PackageVersion Required
	PackageVersion string `json:"packageVersion"`
}

// PackageStatus defines model for PackageStatus.
type PackageStatus struct {
	union json.RawMessage
}

// PackageStatus0 defines model for .
type PackageStatus0 struct {
	PACKAGESTATUSREGISTERED PACKAGESTATUSREGISTERED `json:"PACKAGE_STATUS_REGISTERED"`
}

// PackageStatus1 defines model for .
type PackageStatus1 struct {
	PACKAGESTATUSUNSPECIFIED PACKAGESTATUSUNSPECIFIED `json:"PACKAGE_STATUS_UNSPECIFIED"`
}

// PackageStatus2 defines model for .
type PackageStatus2 struct {
	Recognized Recognized `json:"Recognized"`
}

// PackageStatus3 defines model for .
type PackageStatus3 struct {
	Unrecognized Unrecognized1 `json:"Unrecognized"`
}

// ParticipantAdmin defines model for ParticipantAdmin.
type ParticipantAdmin struct {
	Value ParticipantAdmin1 `json:"value"`
}

// ParticipantAdmin1 defines model for ParticipantAdmin1.
type ParticipantAdmin1 = map[string]interface{}

// ParticipantAuthorizationAdded defines model for ParticipantAuthorizationAdded.
type ParticipantAuthorizationAdded struct {
	// ParticipantId Required
	ParticipantId string `json:"participantId"`

	// ParticipantPermission Required
	ParticipantPermission int32 `json:"participantPermission"`

	// PartyId Required
	PartyId string `json:"partyId"`
}

// ParticipantAuthorizationChanged defines model for ParticipantAuthorizationChanged.
type ParticipantAuthorizationChanged struct {
	// ParticipantId Required
	ParticipantId string `json:"participantId"`

	// ParticipantPermission Required
	ParticipantPermission int32 `json:"participantPermission"`

	// PartyId Required
	PartyId string `json:"partyId"`
}

// ParticipantAuthorizationRevoked defines model for ParticipantAuthorizationRevoked.
type ParticipantAuthorizationRevoked struct {
	// ParticipantId Required
	ParticipantId string `json:"participantId"`

	// PartyId Required
	PartyId string `json:"partyId"`
}

// ParticipantAuthorizationTopologyFormat A format specifying which participant authorization topology transactions to include and how to render them.
type ParticipantAuthorizationTopologyFormat struct {
	// Parties List of parties for which the topology transactions should be sent.
	// Empty means: for all parties.
	Parties *[]string `json:"parties,omitempty"`
}

// ParticipantPermission defines model for ParticipantPermission.
type ParticipantPermission struct {
	union json.RawMessage
}

// ParticipantPermission0 defines model for .
type ParticipantPermission0 struct {
	PARTICIPANTPERMISSIONCONFIRMATION PARTICIPANTPERMISSIONCONFIRMATION `json:"PARTICIPANT_PERMISSION_CONFIRMATION"`
}

// ParticipantPermission1 defines model for .
type ParticipantPermission1 struct {
	PARTICIPANTPERMISSIONOBSERVATION PARTICIPANTPERMISSIONOBSERVATION `json:"PARTICIPANT_PERMISSION_OBSERVATION"`
}

// ParticipantPermission2 defines model for .
type ParticipantPermission2 struct {
	PARTICIPANTPERMISSIONSUBMISSION PARTICIPANTPERMISSIONSUBMISSION `json:"PARTICIPANT_PERMISSION_SUBMISSION"`
}

// ParticipantPermission3 defines model for .
type ParticipantPermission3 struct {
	PARTICIPANTPERMISSIONUNSPECIFIED PARTICIPANTPERMISSIONUNSPECIFIED `json:"PARTICIPANT_PERMISSION_UNSPECIFIED"`
}

// ParticipantPermission4 defines model for .
type ParticipantPermission4 struct {
	ParticipantPermissionRecognized ParticipantPermissionRecognized `json:"Recognized"`
}

// ParticipantPermission5 defines model for .
type ParticipantPermission5 struct {
	Unrecognized Unrecognized2 `json:"Unrecognized"`
}

// PartyDetails defines model for PartyDetails.
type PartyDetails struct {
	// IdentityProviderId The id of the ``Identity Provider``
	// Optional, if not set, there could be 3 options:
	//
	// 1. the party is managed by the default identity provider.
	// 2. party is not hosted by the participant.
	// 3. party is hosted by the participant, but is outside of the user's identity provider.
	IdentityProviderId string `json:"identityProviderId"`

	// IsLocal true if party is hosted by the participant and the party shares the same identity provider as the user issuing the request.
	// Optional
	IsLocal bool `json:"isLocal"`

	// LocalMetadata Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
	//
	// Based on ``ObjectMeta`` meta used in Kubernetes API.
	// See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640
	LocalMetadata *ObjectMeta `json:"localMetadata,omitempty"`

	// Party The stable unique identifier of a Daml party.
	// Must be a valid PartyIdString (as described in ``value.proto``).
	// Required
	Party string `json:"party"`
}

// PartyManagementFeature defines model for PartyManagementFeature.
type PartyManagementFeature struct {
	// MaxPartiesPageSize The maximum number of parties the server can return in a single response (page).
	MaxPartiesPageSize int32 `json:"maxPartiesPageSize"`
}

// PartySignatures Additional signatures provided by the submitting parties
type PartySignatures struct {
	// Signatures Additional signatures provided by all individual parties
	Signatures *[]SinglePartySignatures `json:"signatures,omitempty"`
}

// Reassignment Complete view of an on-ledger reassignment.
type Reassignment struct {
	// Value Complete view of an on-ledger reassignment.
	Value JsReassignment `json:"value"`
}

// Reassignment1 Complete view of an on-ledger reassignment.
type Reassignment1 struct {
	// Value Complete view of an on-ledger reassignment.
	Value JsReassignment `json:"value"`
}

// ReassignmentCommand defines model for ReassignmentCommand.
type ReassignmentCommand struct {
	// ReassignmentCommandUnion A command can either create a new contract or exercise a choice on an existing contract.
	ReassignmentCommandUnion ReassignmentCommandUnion `json:"command"`
}

// ReassignmentCommands defines model for ReassignmentCommands.
type ReassignmentCommands struct {
	// CommandId Uniquely identifies the command.
	// The triple (user_id, submitter, command_id) constitutes the change ID for the intended ledger change.
	// The change ID can be used for matching the intended ledger changes with all their completions.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	CommandId string `json:"commandId"`

	// Commands Individual elements of this reassignment. Must be non-empty.
	Commands *[]ReassignmentCommand `json:"commands,omitempty"`

	// SubmissionId A unique identifier to distinguish completions for different submissions with the same change ID.
	// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
	// with the same change ID.
	// Must be a valid LedgerString (as described in ``value.proto``).
	//
	// If omitted, the participant or the committer may set a value of their choice.
	// Optional
	SubmissionId string `json:"submissionId"`

	// Submitter Party on whose behalf the command should be executed.
	// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
	// to act on behalf of the given party.
	// Must be a valid PartyIdString (as described in ``value.proto``).
	// Required
	Submitter string `json:"submitter"`

	// UserId Uniquely identifies the participant user that issued the command.
	// Must be a valid UserIdString (as described in ``value.proto``).
	// Required unless authentication is used with a user token.
	// In that case, the token's user-id will be used for the request's user_id.
	UserId string `json:"userId"`

	// WorkflowId Identifier of the on-ledger workflow that this command is a part of.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Optional
	WorkflowId string `json:"workflowId"`
}

// Recognized defines model for Recognized.
type Recognized struct {
	union json.RawMessage
}

// Recognized0 defines model for .
type Recognized0 struct {
	PACKAGESTATUSREGISTERED PACKAGESTATUSREGISTERED `json:"PACKAGE_STATUS_REGISTERED"`
}

// Recognized1 defines model for .
type Recognized1 struct {
	PACKAGESTATUSUNSPECIFIED PACKAGESTATUSUNSPECIFIED `json:"PACKAGE_STATUS_UNSPECIFIED"`
}

// ParticipantPermissionRecognized defines model for Recognized1.
type ParticipantPermissionRecognized struct {
	union json.RawMessage
}

// Recognized10 defines model for .
type Recognized10 struct {
	PARTICIPANTPERMISSIONCONFIRMATION PARTICIPANTPERMISSIONCONFIRMATION `json:"PARTICIPANT_PERMISSION_CONFIRMATION"`
}

// Recognized11 defines model for .
type Recognized11 struct {
	PARTICIPANTPERMISSIONOBSERVATION PARTICIPANTPERMISSIONOBSERVATION `json:"PARTICIPANT_PERMISSION_OBSERVATION"`
}

// Recognized12 defines model for .
type Recognized12 struct {
	PARTICIPANTPERMISSIONSUBMISSION PARTICIPANTPERMISSIONSUBMISSION `json:"PARTICIPANT_PERMISSION_SUBMISSION"`
}

// Recognized13 defines model for .
type Recognized13 struct {
	PARTICIPANTPERMISSIONUNSPECIFIED PARTICIPANTPERMISSIONUNSPECIFIED `json:"PARTICIPANT_PERMISSION_UNSPECIFIED"`
}

// Recognized2 defines model for Recognized2.
type Recognized2 struct {
	union json.RawMessage
}

// RevokeUserRightsRequest Remove the rights from the set of rights granted to the user.
//
// Required authorization: “HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)“
type RevokeUserRightsRequest struct {
	// IdentityProviderId The id of the ``Identity Provider``
	// Optional, if not set, assume the user is managed by the default identity provider.
	IdentityProviderId string `json:"identityProviderId"`

	// Rights The rights to revoke.
	// Optional
	Rights *[]Right `json:"rights,omitempty"`

	// UserId The user from whom to revoke rights.
	// Required
	UserId string `json:"userId"`
}

// RevokeUserRightsResponse defines model for RevokeUserRightsResponse.
type RevokeUserRightsResponse struct {
	// NewlyRevokedRights The rights that were actually revoked by the request.
	NewlyRevokedRights *[]Right `json:"newlyRevokedRights,omitempty"`
}

// Right A right granted to a user.
type Right struct {
	Kind Kind `json:"kind"`
}

// SIGNATUREFORMATCONCAT defines model for SIGNATURE_FORMAT_CONCAT.
type SIGNATUREFORMATCONCAT = map[string]interface{}

// SIGNATUREFORMATDER defines model for SIGNATURE_FORMAT_DER.
type SIGNATUREFORMATDER = map[string]interface{}

// SIGNATUREFORMATRAW defines model for SIGNATURE_FORMAT_RAW.
type SIGNATUREFORMATRAW = map[string]interface{}

// SIGNATUREFORMATSYMBOLIC defines model for SIGNATURE_FORMAT_SYMBOLIC.
type SIGNATUREFORMATSYMBOLIC = map[string]interface{}

// SIGNATUREFORMATUNSPECIFIED defines model for SIGNATURE_FORMAT_UNSPECIFIED.
type SIGNATUREFORMATUNSPECIFIED = map[string]interface{}

// SIGNINGALGORITHMSPECECDSASHA256 defines model for SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256.
type SIGNINGALGORITHMSPECECDSASHA256 = map[string]interface{}

// SIGNINGALGORITHMSPECECDSASHA384 defines model for SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384.
type SIGNINGALGORITHMSPECECDSASHA384 = map[string]interface{}

// SIGNINGALGORITHMSPECED25519 defines model for SIGNING_ALGORITHM_SPEC_ED25519.
type SIGNINGALGORITHMSPECED25519 = map[string]interface{}

// SIGNINGALGORITHMSPECUNSPECIFIED defines model for SIGNING_ALGORITHM_SPEC_UNSPECIFIED.
type SIGNINGALGORITHMSPECUNSPECIFIED = map[string]interface{}

// Signature defines model for Signature.
type Signature struct {
	Format    SignatureFormat `json:"format"`
	Signature string          `json:"signature"`

	// SignedBy The fingerprint/id of the keypair used to create this signature and needed to verify.
	SignedBy             string               `json:"signedBy"`
	SigningAlgorithmSpec SigningAlgorithmSpec `json:"signingAlgorithmSpec"`
}

// SignatureFormat defines model for SignatureFormat.
type SignatureFormat struct {
	union json.RawMessage
}

// SigningAlgorithmSpec defines model for SigningAlgorithmSpec.
type SigningAlgorithmSpec struct {
	union json.RawMessage
}

// SinglePartySignatures Signatures provided by a single party
type SinglePartySignatures struct {
	// Party Submitting party
	Party string `json:"party"`

	// Signatures Signatures
	Signatures *[]Signature `json:"signatures,omitempty"`
}

// Status defines model for Status.
type Status struct {
	Code          int32  `json:"code"`
	Details       *[]Any `json:"details,omitempty"`
	Message       string `json:"message"`
	UnknownFields string `json:"unknownFields"`
}

// SubmitAndWaitForReassignmentRequest This reassignment is executed as a single atomic update.
type SubmitAndWaitForReassignmentRequest struct {
	// EventFormat A format for events which defines both which events should be included
	// and what data should be computed and included for them.
	//
	// Note that some of the filtering behavior depends on the `TransactionShape`,
	// which is expected to be specified alongside usages of `EventFormat`.
	EventFormat          *EventFormat          `json:"eventFormat,omitempty"`
	ReassignmentCommands *ReassignmentCommands `json:"reassignmentCommands,omitempty"`
}

// SubmitAndWaitResponse defines model for SubmitAndWaitResponse.
type SubmitAndWaitResponse struct {
	// CompletionOffset The details of the offset field are described in ``community/ledger-api/README.md``.
	// Required
	CompletionOffset int64 `json:"completionOffset"`

	// UpdateId The id of the transaction that resulted from the submitted command.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UpdateId string `json:"updateId"`
}

// SubmitReassignmentRequest defines model for SubmitReassignmentRequest.
type SubmitReassignmentRequest struct {
	ReassignmentCommands *ReassignmentCommands `json:"reassignmentCommands,omitempty"`
}

// SubmitReassignmentResponse defines model for SubmitReassignmentResponse.
type SubmitReassignmentResponse = map[string]interface{}

// SubmitResponse defines model for SubmitResponse.
type SubmitResponse = map[string]interface{}

// SynchronizerTime defines model for SynchronizerTime.
type SynchronizerTime struct {
	// RecordTime All commands with a maximum record time below this value MUST be considered lost if their completion has not arrived before this checkpoint.
	// Required
	RecordTime *string `json:"recordTime,omitempty"`

	// SynchronizerId The id of the synchronizer.
	// Required
	SynchronizerId string `json:"synchronizerId"`
}

// TRANSACTIONSHAPEACSDELTA defines model for TRANSACTION_SHAPE_ACS_DELTA.
type TRANSACTIONSHAPEACSDELTA = map[string]interface{}

// TRANSACTIONSHAPELEDGEREFFECTS defines model for TRANSACTION_SHAPE_LEDGER_EFFECTS.
type TRANSACTIONSHAPELEDGEREFFECTS = map[string]interface{}

// TRANSACTIONSHAPEUNSPECIFIED defines model for TRANSACTION_SHAPE_UNSPECIFIED.
type TRANSACTIONSHAPEUNSPECIFIED = map[string]interface{}

// TemplateFilter This filter matches contracts of a specific template.
type TemplateFilter struct {
	// Value This filter matches contracts of a specific template.
	Value TemplateFilter1 `json:"value"`
}

// TemplateFilter1 This filter matches contracts of a specific template.
type TemplateFilter1 struct {
	// IncludeCreatedEventBlob Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
	// Use this to access the contract event payload in your API client
	// for submitting it as a disclosed contract with future commands.
	// Optional
	IncludeCreatedEventBlob bool `json:"includeCreatedEventBlob"`

	// TemplateId A template for which the payload should be included in the response.
	// The ``template_id`` needs to be valid: corresponding template should be defined in
	// one of the available packages at the time of the query.
	// Both package-name and package-id reference formats for the identifier are supported.
	// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
	//
	// Required
	TemplateId *string `json:"templateId,omitempty"`
}

// Time defines model for Time.
type Time struct {
	union json.RawMessage
}

// Time0 defines model for .
type Time0 struct {
	Empty Empty6 `json:"Empty"`
}

// Time1 defines model for .
type Time1 struct {
	MinLedgerTimeAbs MinLedgerTimeAbs `json:"MinLedgerTimeAbs"`
}

// Time2 defines model for .
type Time2 struct {
	MinLedgerTimeRel MinLedgerTimeRel `json:"MinLedgerTimeRel"`
}

// TopologyFormat A format specifying which topology transactions to include and how to render them.
type TopologyFormat struct {
	// IncludeParticipantAuthorizationEvents A format specifying which participant authorization topology transactions to include and how to render them.
	IncludeParticipantAuthorizationEvents *ParticipantAuthorizationTopologyFormat `json:"includeParticipantAuthorizationEvents,omitempty"`
}

// TopologyTransaction defines model for TopologyTransaction.
type TopologyTransaction struct {
	Value JsTopologyTransaction `json:"value"`
}

// TraceContext defines model for TraceContext.
type TraceContext struct {
	// Traceparent https://www.w3.org/TR/trace-context/
	Traceparent *string `json:"traceparent,omitempty"`
	Tracestate  *string `json:"tracestate,omitempty"`
}

// Transaction Filtered view of an on-ledger transaction's create and archive events.
type Transaction struct {
	// Value Filtered view of an on-ledger transaction's create and archive events.
	Value JsTransaction `json:"value"`
}

// TransactionFilter Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
// Used both for filtering create and archive events as well as for filtering transaction trees.
type TransactionFilter struct {
	FiltersByParty MapFilters `json:"filtersByParty"`

	// FiltersForAnyParty The union of a set of template filters, interface filters, or a wildcard.
	FiltersForAnyParty *Filters `json:"filtersForAnyParty,omitempty"`
}

// TransactionFormat A format that specifies what events to include in Daml transactions
// and what data to compute and include for them.
type TransactionFormat struct {
	// EventFormat A format for events which defines both which events should be included
	// and what data should be computed and included for them.
	//
	// Note that some of the filtering behavior depends on the `TransactionShape`,
	// which is expected to be specified alongside usages of `EventFormat`.
	EventFormat      *EventFormat     `json:"eventFormat,omitempty"`
	TransactionShape TransactionShape `json:"transactionShape"`
}

// TransactionShape defines model for TransactionShape.
type TransactionShape struct {
	union json.RawMessage
}

// TransactionTree Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
// Complete view of an on-ledger transaction.
type TransactionTree struct {
	// Value Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// Complete view of an on-ledger transaction.
	Value JsTransactionTree `json:"value"`
}

// TreeEvent Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
// Each tree event message type below contains a “witness_parties“ field which
// indicates the subset of the requested parties that can see the event
// in question.
//
// Note that transaction trees might contain events with
// _no_ witness parties, which were included simply because they were
// children of events which have witnesses.
type TreeEvent struct {
	union json.RawMessage
}

// TreeEvent0 defines model for .
type TreeEvent0 struct {
	CreatedTreeEvent CreatedTreeEvent `json:"CreatedTreeEvent"`
}

// TreeEvent1 defines model for .
type TreeEvent1 struct {
	ExercisedTreeEvent ExercisedTreeEvent `json:"ExercisedTreeEvent"`
}

// Tuple2StringString defines model for Tuple2_String_String.
type Tuple2StringString = []string

// UnassignCommand Unassign a contract
type UnassignCommand struct {
	// Value Unassign a contract
	Value UnassignCommand1 `json:"value"`
}

// UnassignCommand1 Unassign a contract
type UnassignCommand1 struct {
	// ContractId The ID of the contract the client wants to unassign.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	ContractId string `json:"contractId"`

	// Source The ID of the source synchronizer
	// Must be a valid synchronizer id
	// Required
	Source string `json:"source"`

	// Target The ID of the target synchronizer
	// Must be a valid synchronizer id
	// Required
	Target string `json:"target"`
}

// UnassignedEvent Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
type UnassignedEvent struct {
	// AssignmentExclusivity Assignment exclusivity
	// Before this time (measured on the target synchronizer), only the submitter of the unassignment can initiate the assignment
	// Defined for reassigning participants.
	// Optional
	AssignmentExclusivity *string `json:"assignmentExclusivity,omitempty"`

	// ContractId The ID of the reassigned contract.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	ContractId string `json:"contractId"`

	// NodeId The position of this event in the originating reassignment.
	// Node IDs are not necessarily equal across participants,
	// as these may see different projections/parts of reassignments.
	// Required, must be valid node ID (non-negative integer)
	NodeId int32 `json:"nodeId"`

	// Offset The offset of origin.
	// Offsets are managed by the participant nodes.
	// Reassignments can thus NOT be assumed to have the same offsets on different participant nodes.
	// Required, it is a valid absolute offset (positive integer)
	Offset int64 `json:"offset"`

	// PackageName The package name of the contract.
	// Required
	PackageName string `json:"packageName"`

	// ReassignmentCounter Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
	// with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
	// equals zero.
	// Required
	ReassignmentCounter int64 `json:"reassignmentCounter"`

	// Source The ID of the source synchronizer
	// Must be a valid synchronizer id
	// Required
	Source string `json:"source"`

	// Submitter Party on whose behalf the unassign command was executed.
	// Empty if the unassignment happened offline via the repair service.
	// Must be a valid PartyIdString (as described in ``value.proto``).
	// Optional
	Submitter string `json:"submitter"`

	// Target The ID of the target synchronizer
	// Must be a valid synchronizer id
	// Required
	Target string `json:"target"`

	// TemplateId The template of the reassigned contract.
	// The identifier uses the package-id reference format.
	//
	// Required
	TemplateId *string `json:"templateId,omitempty"`

	// UnassignId The ID of the unassignment. This needs to be used as an input for a assign ReassignmentCommand.
	// For one contract the (unassign_id, source synchronizer) pair is unique.
	// Must be a valid LedgerString (as described in ``value.proto``).
	// Required
	UnassignId string `json:"unassignId"`

	// WitnessParties The parties that are notified of this event.
	// Required
	WitnessParties *[]string `json:"witnessParties,omitempty"`
}

// Unrecognized defines model for Unrecognized.
type Unrecognized struct {
	UnrecognizedValue int32 `json:"unrecognizedValue"`
}

// Unrecognized1 defines model for Unrecognized1.
type Unrecognized1 struct {
	UnrecognizedValue int32 `json:"unrecognizedValue"`
}

// Unrecognized2 defines model for Unrecognized2.
type Unrecognized2 struct {
	UnrecognizedValue int32 `json:"unrecognizedValue"`
}

// Unrecognized3 defines model for Unrecognized3.
type Unrecognized3 struct {
	UnrecognizedValue int32 `json:"unrecognizedValue"`
}

// Unrecognized4 defines model for Unrecognized4.
type Unrecognized4 struct {
	UnrecognizedValue int32 `json:"unrecognizedValue"`
}

// Unrecognized5 defines model for Unrecognized5.
type Unrecognized5 struct {
	UnrecognizedValue int32 `json:"unrecognizedValue"`
}

// Update The update that matches the filter in the request.
type Update struct {
	union json.RawMessage
}

// Update0 defines model for .
type Update0 struct {
	// OffsetCheckpoint OffsetCheckpoints may be used to:
	//
	// - detect time out of commands.
	// - provide an offset which can be used to restart consumption.
	OffsetCheckpoint OffsetCheckpoint2 `json:"OffsetCheckpoint"`
}

// Update1 defines model for .
type Update1 struct {
	// Reassignment Complete view of an on-ledger reassignment.
	Reassignment Reassignment `json:"Reassignment"`
}

// Update2 defines model for .
type Update2 struct {
	TopologyTransaction TopologyTransaction `json:"TopologyTransaction"`
}

// Update3 defines model for .
type Update3 struct {
	// Transaction Filtered view of an on-ledger transaction's create and archive events.
	Transaction Transaction `json:"Transaction"`
}

// UpdateUnion The update that matches the filter in the request.
type UpdateUnion struct {
	union json.RawMessage
}

// Update10 defines model for .
type Update10 struct {
	// OffsetCheckpoint OffsetCheckpoints may be used to:
	//
	// - detect time out of commands.
	// - provide an offset which can be used to restart consumption.
	OffsetCheckpoint OffsetCheckpoint3 `json:"OffsetCheckpoint"`
}

// Update11 defines model for .
type Update11 struct {
	// Reassignment Complete view of an on-ledger reassignment.
	Reassignment Reassignment1 `json:"Reassignment"`
}

// Update12 defines model for .
type Update12 struct {
	// TransactionTree Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
	// Complete view of an on-ledger transaction.
	TransactionTree TransactionTree `json:"TransactionTree"`
}

// UpdateFormat A format specifying what updates to include and how to render them.
type UpdateFormat struct {
	// IncludeReassignments A format for events which defines both which events should be included
	// and what data should be computed and included for them.
	//
	// Note that some of the filtering behavior depends on the `TransactionShape`,
	// which is expected to be specified alongside usages of `EventFormat`.
	IncludeReassignments *EventFormat `json:"includeReassignments,omitempty"`

	// IncludeTopologyEvents A format specifying which topology transactions to include and how to render them.
	IncludeTopologyEvents *TopologyFormat `json:"includeTopologyEvents,omitempty"`

	// IncludeTransactions A format that specifies what events to include in Daml transactions
	// and what data to compute and include for them.
	IncludeTransactions *TransactionFormat `json:"includeTransactions,omitempty"`
}

// UpdateIdentityProviderConfigRequest defines model for UpdateIdentityProviderConfigRequest.
type UpdateIdentityProviderConfigRequest struct {
	IdentityProviderConfig *IdentityProviderConfig `json:"identityProviderConfig,omitempty"`
	UpdateMask             *FieldMask              `json:"updateMask,omitempty"`
}

// UpdateIdentityProviderConfigResponse defines model for UpdateIdentityProviderConfigResponse.
type UpdateIdentityProviderConfigResponse struct {
	IdentityProviderConfig *IdentityProviderConfig `json:"identityProviderConfig,omitempty"`
}

// UpdatePartyDetailsRequest Required authorization: “HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(party_details.identity_provider_id)“
type UpdatePartyDetailsRequest struct {
	PartyDetails *PartyDetails `json:"partyDetails,omitempty"`
	UpdateMask   *FieldMask    `json:"updateMask,omitempty"`
}

// UpdatePartyDetailsResponse defines model for UpdatePartyDetailsResponse.
type UpdatePartyDetailsResponse struct {
	PartyDetails *PartyDetails `json:"partyDetails,omitempty"`
}

// UpdateUserIdentityProviderIdRequest Required authorization: “HasRight(ParticipantAdmin)“
type UpdateUserIdentityProviderIdRequest struct {
	// SourceIdentityProviderId Current identity provider ID of the user
	SourceIdentityProviderId string `json:"sourceIdentityProviderId"`

	// TargetIdentityProviderId Target identity provider ID of the user
	TargetIdentityProviderId string `json:"targetIdentityProviderId"`

	// UserId User to update
	UserId string `json:"userId"`
}

// UpdateUserIdentityProviderIdResponse defines model for UpdateUserIdentityProviderIdResponse.
type UpdateUserIdentityProviderIdResponse = map[string]interface{}

// UpdateUserRequest Required authorization: “HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)“
type UpdateUserRequest struct {
	UpdateMask *FieldMask `json:"updateMask,omitempty"`

	// User  Users and rights
	// /////////////////
	//  Users are used to dynamically manage the rights given to Daml applications.
	//  They are stored and managed per participant node.
	User *User `json:"user,omitempty"`
}

// UpdateUserResponse defines model for UpdateUserResponse.
type UpdateUserResponse struct {
	// User  Users and rights
	// /////////////////
	//  Users are used to dynamically manage the rights given to Daml applications.
	//  They are stored and managed per participant node.
	User *User `json:"user,omitempty"`
}

// UploadDarFileResponse A message that is received when the upload operation succeeded.
type UploadDarFileResponse = map[string]interface{}

// User  Users and rights
// /////////////////
//
//	Users are used to dynamically manage the rights given to Daml applications.
//	They are stored and managed per participant node.
type User struct {
	// Id The user identifier, which must be a non-empty string of at most 128
	// characters that are either alphanumeric ASCII characters or one of the symbols "@^$.!`-#+'~_|:".
	// Required
	Id string `json:"id"`

	// IdentityProviderId The ID of the identity provider configured by ``Identity Provider Config``
	// Optional, if not set, assume the user is managed by the default identity provider.
	IdentityProviderId string `json:"identityProviderId"`

	// IsDeactivated When set, then the user is denied all access to the Ledger API.
	// Otherwise, the user has access to the Ledger API as per the user's rights.
	// Optional,
	// Modifiable
	IsDeactivated bool `json:"isDeactivated"`

	// Metadata Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
	//
	// Based on ``ObjectMeta`` meta used in Kubernetes API.
	// See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640
	Metadata *ObjectMeta `json:"metadata,omitempty"`

	// PrimaryParty The primary party as which this user reads and acts by default on the ledger
	// *provided* it has the corresponding ``CanReadAs(primary_party)`` or
	// ``CanActAs(primary_party)`` rights.
	// Ledger API clients SHOULD set this field to a non-empty value for all users to
	// enable the users to act on the ledger using their own Daml party.
	// Users for participant administrators MAY have an associated primary party.
	// Optional,
	// Modifiable
	PrimaryParty string `json:"primaryParty"`
}

// UserManagementFeature defines model for UserManagementFeature.
type UserManagementFeature struct {
	// MaxRightsPerUser The maximum number of rights that can be assigned to a single user.
	// Servers MUST support at least 100 rights per user.
	// A value of 0 means that the server enforces no rights per user limit.
	MaxRightsPerUser int32 `json:"maxRightsPerUser"`

	// MaxUsersPageSize The maximum number of users the server can return in a single response (page).
	// Servers MUST support at least a 100 users per page.
	// A value of 0 means that the server enforces no page size limit.
	MaxUsersPageSize int32 `json:"maxUsersPageSize"`

	// Supported Whether the Ledger API server provides the user management service.
	Supported bool `json:"supported"`
}

// WildcardFilter This filter matches all templates.
type WildcardFilter struct {
	// Value This filter matches all templates.
	Value WildcardFilter1 `json:"value"`
}

// WildcardFilter1 This filter matches all templates.
type WildcardFilter1 struct {
	// IncludeCreatedEventBlob Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
	// Use this to access the contract create event payload in your API client
	// for submitting it as a disclosed contract with future commands.
	// Optional
	IncludeCreatedEventBlob bool `json:"includeCreatedEventBlob"`
}

// PostV2CommandsCompletionsParams defines parameters for PostV2CommandsCompletions.
type PostV2CommandsCompletionsParams struct {
	// Limit maximum number of elements to return, this param is ignored if is bigger than server setting
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// StreamIdleTimeoutMs timeout to complete and send result if no new elements are received (for open ended streams)
	StreamIdleTimeoutMs *int64 `form:"stream_idle_timeout_ms,omitempty" json:"stream_idle_timeout_ms,omitempty"`
}

// GetV2InteractiveSubmissionPreferredPackageVersionParams defines parameters for GetV2InteractiveSubmissionPreferredPackageVersion.
type GetV2InteractiveSubmissionPreferredPackageVersionParams struct {
	Parties        *[]string  `form:"parties,omitempty" json:"parties,omitempty"`
	PackageName    string     `form:"package-name" json:"package-name"`
	VettingValidAt *time.Time `form:"vetting_valid_at,omitempty" json:"vetting_valid_at,omitempty"`
	SynchronizerId *string    `form:"synchronizer-id,omitempty" json:"synchronizer-id,omitempty"`
}

// GetV2PartiesParams defines parameters for GetV2Parties.
type GetV2PartiesParams struct {
	// PageSize maximum number of elements in a returned page
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken token - to continue results from a given page, leave empty to start from the beginning of the list, obtain token from the result of previous page
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetV2PartiesPartyParams defines parameters for GetV2PartiesParty.
type GetV2PartiesPartyParams struct {
	IdentityProviderId *string   `form:"identity-provider-id,omitempty" json:"identity-provider-id,omitempty"`
	Parties            *[]string `form:"parties,omitempty" json:"parties,omitempty"`
}

// PostV2StateActiveContractsParams defines parameters for PostV2StateActiveContracts.
type PostV2StateActiveContractsParams struct {
	// Limit maximum number of elements to return, this param is ignored if is bigger than server setting
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// StreamIdleTimeoutMs timeout to complete and send result if no new elements are received (for open ended streams)
	StreamIdleTimeoutMs *int64 `form:"stream_idle_timeout_ms,omitempty" json:"stream_idle_timeout_ms,omitempty"`
}

// GetV2StateConnectedSynchronizersParams defines parameters for GetV2StateConnectedSynchronizers.
type GetV2StateConnectedSynchronizersParams struct {
	Party         string  `form:"party" json:"party"`
	ParticipantId *string `form:"participantId,omitempty" json:"participantId,omitempty"`
}

// PostV2UpdatesFlatsParams defines parameters for PostV2UpdatesFlats.
type PostV2UpdatesFlatsParams struct {
	// Limit maximum number of elements to return, this param is ignored if is bigger than server setting
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// StreamIdleTimeoutMs timeout to complete and send result if no new elements are received (for open ended streams)
	StreamIdleTimeoutMs *int64 `form:"stream_idle_timeout_ms,omitempty" json:"stream_idle_timeout_ms,omitempty"`
}

// GetV2UpdatesTransactionTreeByIdUpdateIdParams defines parameters for GetV2UpdatesTransactionTreeByIdUpdateId.
type GetV2UpdatesTransactionTreeByIdUpdateIdParams struct {
	Parties *[]string `form:"parties,omitempty" json:"parties,omitempty"`
}

// GetV2UpdatesTransactionTreeByOffsetOffsetParams defines parameters for GetV2UpdatesTransactionTreeByOffsetOffset.
type GetV2UpdatesTransactionTreeByOffsetOffsetParams struct {
	Parties *[]string `form:"parties,omitempty" json:"parties,omitempty"`
}

// PostV2UpdatesTreesParams defines parameters for PostV2UpdatesTrees.
type PostV2UpdatesTreesParams struct {
	// Limit maximum number of elements to return, this param is ignored if is bigger than server setting
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// StreamIdleTimeoutMs timeout to complete and send result if no new elements are received (for open ended streams)
	StreamIdleTimeoutMs *int64 `form:"stream_idle_timeout_ms,omitempty" json:"stream_idle_timeout_ms,omitempty"`
}

// GetV2UsersParams defines parameters for GetV2Users.
type GetV2UsersParams struct {
	// PageSize maximum number of elements in a returned page
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken token - to continue results from a given page, leave empty to start from the beginning of the list, obtain token from the result of previous page
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// PostV2CommandsAsyncSubmitJSONRequestBody defines body for PostV2CommandsAsyncSubmit for application/json ContentType.
type PostV2CommandsAsyncSubmitJSONRequestBody = JsCommands

// PostV2CommandsAsyncSubmitReassignmentJSONRequestBody defines body for PostV2CommandsAsyncSubmitReassignment for application/json ContentType.
type PostV2CommandsAsyncSubmitReassignmentJSONRequestBody = SubmitReassignmentRequest

// PostV2CommandsCompletionsJSONRequestBody defines body for PostV2CommandsCompletions for application/json ContentType.
type PostV2CommandsCompletionsJSONRequestBody = CompletionStreamRequest

// PostV2CommandsSubmitAndWaitJSONRequestBody defines body for PostV2CommandsSubmitAndWait for application/json ContentType.
type PostV2CommandsSubmitAndWaitJSONRequestBody = JsCommands

// PostV2CommandsSubmitAndWaitForReassignmentJSONRequestBody defines body for PostV2CommandsSubmitAndWaitForReassignment for application/json ContentType.
type PostV2CommandsSubmitAndWaitForReassignmentJSONRequestBody = SubmitAndWaitForReassignmentRequest

// PostV2CommandsSubmitAndWaitForTransactionJSONRequestBody defines body for PostV2CommandsSubmitAndWaitForTransaction for application/json ContentType.
type PostV2CommandsSubmitAndWaitForTransactionJSONRequestBody = JsSubmitAndWaitForTransactionRequest

// PostV2CommandsSubmitAndWaitForTransactionTreeJSONRequestBody defines body for PostV2CommandsSubmitAndWaitForTransactionTree for application/json ContentType.
type PostV2CommandsSubmitAndWaitForTransactionTreeJSONRequestBody = JsCommands

// PostV2EventsEventsByContractIdJSONRequestBody defines body for PostV2EventsEventsByContractId for application/json ContentType.
type PostV2EventsEventsByContractIdJSONRequestBody = GetEventsByContractIdRequest

// PostV2IdpsJSONRequestBody defines body for PostV2Idps for application/json ContentType.
type PostV2IdpsJSONRequestBody = CreateIdentityProviderConfigRequest

// PatchV2IdpsIdpIdJSONRequestBody defines body for PatchV2IdpsIdpId for application/json ContentType.
type PatchV2IdpsIdpIdJSONRequestBody = UpdateIdentityProviderConfigRequest

// PostV2InteractiveSubmissionExecuteJSONRequestBody defines body for PostV2InteractiveSubmissionExecute for application/json ContentType.
type PostV2InteractiveSubmissionExecuteJSONRequestBody = JsExecuteSubmissionRequest

// PostV2InteractiveSubmissionPrepareJSONRequestBody defines body for PostV2InteractiveSubmissionPrepare for application/json ContentType.
type PostV2InteractiveSubmissionPrepareJSONRequestBody = JsPrepareSubmissionRequest

// PostV2PartiesJSONRequestBody defines body for PostV2Parties for application/json ContentType.
type PostV2PartiesJSONRequestBody = AllocatePartyRequest

// PatchV2PartiesPartyJSONRequestBody defines body for PatchV2PartiesParty for application/json ContentType.
type PatchV2PartiesPartyJSONRequestBody = UpdatePartyDetailsRequest

// PostV2StateActiveContractsJSONRequestBody defines body for PostV2StateActiveContracts for application/json ContentType.
type PostV2StateActiveContractsJSONRequestBody = GetActiveContractsRequest

// PostV2UpdatesFlatsJSONRequestBody defines body for PostV2UpdatesFlats for application/json ContentType.
type PostV2UpdatesFlatsJSONRequestBody = GetUpdatesRequest

// PostV2UpdatesTransactionByIdJSONRequestBody defines body for PostV2UpdatesTransactionById for application/json ContentType.
type PostV2UpdatesTransactionByIdJSONRequestBody = GetTransactionByIdRequest

// PostV2UpdatesTransactionByOffsetJSONRequestBody defines body for PostV2UpdatesTransactionByOffset for application/json ContentType.
type PostV2UpdatesTransactionByOffsetJSONRequestBody = GetTransactionByOffsetRequest

// PostV2UpdatesTreesJSONRequestBody defines body for PostV2UpdatesTrees for application/json ContentType.
type PostV2UpdatesTreesJSONRequestBody = GetUpdatesRequest

// PostV2UpdatesUpdateByIdJSONRequestBody defines body for PostV2UpdatesUpdateById for application/json ContentType.
type PostV2UpdatesUpdateByIdJSONRequestBody = GetUpdateByIdRequest

// PostV2UpdatesUpdateByOffsetJSONRequestBody defines body for PostV2UpdatesUpdateByOffset for application/json ContentType.
type PostV2UpdatesUpdateByOffsetJSONRequestBody = GetUpdateByOffsetRequest

// PostV2UsersJSONRequestBody defines body for PostV2Users for application/json ContentType.
type PostV2UsersJSONRequestBody = CreateUserRequest

// PatchV2UsersUserIdJSONRequestBody defines body for PatchV2UsersUserId for application/json ContentType.
type PatchV2UsersUserIdJSONRequestBody = UpdateUserRequest

// PatchV2UsersUserIdIdentityProviderIdJSONRequestBody defines body for PatchV2UsersUserIdIdentityProviderId for application/json ContentType.
type PatchV2UsersUserIdIdentityProviderIdJSONRequestBody = UpdateUserIdentityProviderIdRequest

// PatchV2UsersUserIdRightsJSONRequestBody defines body for PatchV2UsersUserIdRights for application/json ContentType.
type PatchV2UsersUserIdRightsJSONRequestBody = RevokeUserRightsRequest

// PostV2UsersUserIdRightsJSONRequestBody defines body for PostV2UsersUserIdRights for application/json ContentType.
type PostV2UsersUserIdRightsJSONRequestBody = GrantUserRightsRequest

// AsCommand0 returns the union data inside the Command as a Command0
func (t Command) AsCommand0() (Command0, error) {
	var body Command0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand0 overwrites any union data inside the Command as the provided Command0
func (t *Command) FromCommand0(v Command0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand0 performs a merge with any union data inside the Command, using the provided Command0
func (t *Command) MergeCommand0(v Command0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommand1 returns the union data inside the Command as a Command1
func (t Command) AsCommand1() (Command1, error) {
	var body Command1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand1 overwrites any union data inside the Command as the provided Command1
func (t *Command) FromCommand1(v Command1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand1 performs a merge with any union data inside the Command, using the provided Command1
func (t *Command) MergeCommand1(v Command1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommand2 returns the union data inside the Command as a Command2
func (t Command) AsCommand2() (Command2, error) {
	var body Command2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand2 overwrites any union data inside the Command as the provided Command2
func (t *Command) FromCommand2(v Command2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand2 performs a merge with any union data inside the Command, using the provided Command2
func (t *Command) MergeCommand2(v Command2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommand3 returns the union data inside the Command as a Command3
func (t Command) AsCommand3() (Command3, error) {
	var body Command3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand3 overwrites any union data inside the Command as the provided Command3
func (t *Command) FromCommand3(v Command3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand3 performs a merge with any union data inside the Command, using the provided Command3
func (t *Command) MergeCommand3(v Command3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Command) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Command) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCommand10 returns the union data inside the ReassignmentCommandUnion as a Command10
func (t ReassignmentCommandUnion) AsCommand10() (Command10, error) {
	var body Command10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand10 overwrites any union data inside the ReassignmentCommandUnion as the provided Command10
func (t *ReassignmentCommandUnion) FromCommand10(v Command10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand10 performs a merge with any union data inside the ReassignmentCommandUnion, using the provided Command10
func (t *ReassignmentCommandUnion) MergeCommand10(v Command10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommand11 returns the union data inside the ReassignmentCommandUnion as a Command11
func (t ReassignmentCommandUnion) AsCommand11() (Command11, error) {
	var body Command11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand11 overwrites any union data inside the ReassignmentCommandUnion as the provided Command11
func (t *ReassignmentCommandUnion) FromCommand11(v Command11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand11 performs a merge with any union data inside the ReassignmentCommandUnion, using the provided Command11
func (t *ReassignmentCommandUnion) MergeCommand11(v Command11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommand12 returns the union data inside the ReassignmentCommandUnion as a Command12
func (t ReassignmentCommandUnion) AsCommand12() (Command12, error) {
	var body Command12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand12 overwrites any union data inside the ReassignmentCommandUnion as the provided Command12
func (t *ReassignmentCommandUnion) FromCommand12(v Command12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand12 performs a merge with any union data inside the ReassignmentCommandUnion, using the provided Command12
func (t *ReassignmentCommandUnion) MergeCommand12(v Command12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReassignmentCommandUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReassignmentCommandUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCompletionResponse0 returns the union data inside the CompletionResponse as a CompletionResponse0
func (t CompletionResponse) AsCompletionResponse0() (CompletionResponse0, error) {
	var body CompletionResponse0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletionResponse0 overwrites any union data inside the CompletionResponse as the provided CompletionResponse0
func (t *CompletionResponse) FromCompletionResponse0(v CompletionResponse0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletionResponse0 performs a merge with any union data inside the CompletionResponse, using the provided CompletionResponse0
func (t *CompletionResponse) MergeCompletionResponse0(v CompletionResponse0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompletionResponse1 returns the union data inside the CompletionResponse as a CompletionResponse1
func (t CompletionResponse) AsCompletionResponse1() (CompletionResponse1, error) {
	var body CompletionResponse1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletionResponse1 overwrites any union data inside the CompletionResponse as the provided CompletionResponse1
func (t *CompletionResponse) FromCompletionResponse1(v CompletionResponse1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletionResponse1 performs a merge with any union data inside the CompletionResponse, using the provided CompletionResponse1
func (t *CompletionResponse) MergeCompletionResponse1(v CompletionResponse1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompletionResponse2 returns the union data inside the CompletionResponse as a CompletionResponse2
func (t CompletionResponse) AsCompletionResponse2() (CompletionResponse2, error) {
	var body CompletionResponse2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletionResponse2 overwrites any union data inside the CompletionResponse as the provided CompletionResponse2
func (t *CompletionResponse) FromCompletionResponse2(v CompletionResponse2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletionResponse2 performs a merge with any union data inside the CompletionResponse, using the provided CompletionResponse2
func (t *CompletionResponse) MergeCompletionResponse2(v CompletionResponse2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CompletionResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CompletionResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeduplicationPeriod0 returns the union data inside the DeduplicationPeriod as a DeduplicationPeriod0
func (t DeduplicationPeriod) AsDeduplicationPeriod0() (DeduplicationPeriod0, error) {
	var body DeduplicationPeriod0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod0 overwrites any union data inside the DeduplicationPeriod as the provided DeduplicationPeriod0
func (t *DeduplicationPeriod) FromDeduplicationPeriod0(v DeduplicationPeriod0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod0 performs a merge with any union data inside the DeduplicationPeriod, using the provided DeduplicationPeriod0
func (t *DeduplicationPeriod) MergeDeduplicationPeriod0(v DeduplicationPeriod0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeduplicationPeriod1 returns the union data inside the DeduplicationPeriod as a DeduplicationPeriod1
func (t DeduplicationPeriod) AsDeduplicationPeriod1() (DeduplicationPeriod1, error) {
	var body DeduplicationPeriod1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod1 overwrites any union data inside the DeduplicationPeriod as the provided DeduplicationPeriod1
func (t *DeduplicationPeriod) FromDeduplicationPeriod1(v DeduplicationPeriod1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod1 performs a merge with any union data inside the DeduplicationPeriod, using the provided DeduplicationPeriod1
func (t *DeduplicationPeriod) MergeDeduplicationPeriod1(v DeduplicationPeriod1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeduplicationPeriod2 returns the union data inside the DeduplicationPeriod as a DeduplicationPeriod2
func (t DeduplicationPeriod) AsDeduplicationPeriod2() (DeduplicationPeriod2, error) {
	var body DeduplicationPeriod2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod2 overwrites any union data inside the DeduplicationPeriod as the provided DeduplicationPeriod2
func (t *DeduplicationPeriod) FromDeduplicationPeriod2(v DeduplicationPeriod2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod2 performs a merge with any union data inside the DeduplicationPeriod, using the provided DeduplicationPeriod2
func (t *DeduplicationPeriod) MergeDeduplicationPeriod2(v DeduplicationPeriod2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeduplicationPeriod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeduplicationPeriod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeduplicationPeriod10 returns the union data inside the CompletionDeduplicationPeriod as a DeduplicationPeriod10
func (t CompletionDeduplicationPeriod) AsDeduplicationPeriod10() (DeduplicationPeriod10, error) {
	var body DeduplicationPeriod10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod10 overwrites any union data inside the CompletionDeduplicationPeriod as the provided DeduplicationPeriod10
func (t *CompletionDeduplicationPeriod) FromDeduplicationPeriod10(v DeduplicationPeriod10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod10 performs a merge with any union data inside the CompletionDeduplicationPeriod, using the provided DeduplicationPeriod10
func (t *CompletionDeduplicationPeriod) MergeDeduplicationPeriod10(v DeduplicationPeriod10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeduplicationPeriod11 returns the union data inside the CompletionDeduplicationPeriod as a DeduplicationPeriod11
func (t CompletionDeduplicationPeriod) AsDeduplicationPeriod11() (DeduplicationPeriod11, error) {
	var body DeduplicationPeriod11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod11 overwrites any union data inside the CompletionDeduplicationPeriod as the provided DeduplicationPeriod11
func (t *CompletionDeduplicationPeriod) FromDeduplicationPeriod11(v DeduplicationPeriod11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod11 performs a merge with any union data inside the CompletionDeduplicationPeriod, using the provided DeduplicationPeriod11
func (t *CompletionDeduplicationPeriod) MergeDeduplicationPeriod11(v DeduplicationPeriod11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeduplicationPeriod12 returns the union data inside the CompletionDeduplicationPeriod as a DeduplicationPeriod12
func (t CompletionDeduplicationPeriod) AsDeduplicationPeriod12() (DeduplicationPeriod12, error) {
	var body DeduplicationPeriod12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod12 overwrites any union data inside the CompletionDeduplicationPeriod as the provided DeduplicationPeriod12
func (t *CompletionDeduplicationPeriod) FromDeduplicationPeriod12(v DeduplicationPeriod12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod12 performs a merge with any union data inside the CompletionDeduplicationPeriod, using the provided DeduplicationPeriod12
func (t *CompletionDeduplicationPeriod) MergeDeduplicationPeriod12(v DeduplicationPeriod12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CompletionDeduplicationPeriod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CompletionDeduplicationPeriod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeduplicationPeriod20 returns the union data inside the TransactionDeduplicationPeriod as a DeduplicationPeriod20
func (t TransactionDeduplicationPeriod) AsDeduplicationPeriod20() (DeduplicationPeriod20, error) {
	var body DeduplicationPeriod20
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod20 overwrites any union data inside the TransactionDeduplicationPeriod as the provided DeduplicationPeriod20
func (t *TransactionDeduplicationPeriod) FromDeduplicationPeriod20(v DeduplicationPeriod20) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod20 performs a merge with any union data inside the TransactionDeduplicationPeriod, using the provided DeduplicationPeriod20
func (t *TransactionDeduplicationPeriod) MergeDeduplicationPeriod20(v DeduplicationPeriod20) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeduplicationPeriod21 returns the union data inside the TransactionDeduplicationPeriod as a DeduplicationPeriod21
func (t TransactionDeduplicationPeriod) AsDeduplicationPeriod21() (DeduplicationPeriod21, error) {
	var body DeduplicationPeriod21
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod21 overwrites any union data inside the TransactionDeduplicationPeriod as the provided DeduplicationPeriod21
func (t *TransactionDeduplicationPeriod) FromDeduplicationPeriod21(v DeduplicationPeriod21) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod21 performs a merge with any union data inside the TransactionDeduplicationPeriod, using the provided DeduplicationPeriod21
func (t *TransactionDeduplicationPeriod) MergeDeduplicationPeriod21(v DeduplicationPeriod21) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeduplicationPeriod22 returns the union data inside the TransactionDeduplicationPeriod as a DeduplicationPeriod22
func (t TransactionDeduplicationPeriod) AsDeduplicationPeriod22() (DeduplicationPeriod22, error) {
	var body DeduplicationPeriod22
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeduplicationPeriod22 overwrites any union data inside the TransactionDeduplicationPeriod as the provided DeduplicationPeriod22
func (t *TransactionDeduplicationPeriod) FromDeduplicationPeriod22(v DeduplicationPeriod22) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeduplicationPeriod22 performs a merge with any union data inside the TransactionDeduplicationPeriod, using the provided DeduplicationPeriod22
func (t *TransactionDeduplicationPeriod) MergeDeduplicationPeriod22(v DeduplicationPeriod22) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransactionDeduplicationPeriod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransactionDeduplicationPeriod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvent0 returns the union data inside the Event as a Event0
func (t Event) AsEvent0() (Event0, error) {
	var body Event0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvent0 overwrites any union data inside the Event as the provided Event0
func (t *Event) FromEvent0(v Event0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvent0 performs a merge with any union data inside the Event, using the provided Event0
func (t *Event) MergeEvent0(v Event0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvent1 returns the union data inside the Event as a Event1
func (t Event) AsEvent1() (Event1, error) {
	var body Event1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvent1 overwrites any union data inside the Event as the provided Event1
func (t *Event) FromEvent1(v Event1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvent1 performs a merge with any union data inside the Event, using the provided Event1
func (t *Event) MergeEvent1(v Event1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvent2 returns the union data inside the Event as a Event2
func (t Event) AsEvent2() (Event2, error) {
	var body Event2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvent2 overwrites any union data inside the Event as the provided Event2
func (t *Event) FromEvent2(v Event2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvent2 performs a merge with any union data inside the Event, using the provided Event2
func (t *Event) MergeEvent2(v Event2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Event) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Event) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParticipantAuthorizationAdded returns the union data inside the ParticipantEvent as a ParticipantAuthorizationAdded
func (t ParticipantEvent) AsParticipantAuthorizationAdded() (ParticipantAuthorizationAdded, error) {
	var body ParticipantAuthorizationAdded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantAuthorizationAdded overwrites any union data inside the ParticipantEvent as the provided ParticipantAuthorizationAdded
func (t *ParticipantEvent) FromParticipantAuthorizationAdded(v ParticipantAuthorizationAdded) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantAuthorizationAdded performs a merge with any union data inside the ParticipantEvent, using the provided ParticipantAuthorizationAdded
func (t *ParticipantEvent) MergeParticipantAuthorizationAdded(v ParticipantAuthorizationAdded) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParticipantAuthorizationChanged returns the union data inside the ParticipantEvent as a ParticipantAuthorizationChanged
func (t ParticipantEvent) AsParticipantAuthorizationChanged() (ParticipantAuthorizationChanged, error) {
	var body ParticipantAuthorizationChanged
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantAuthorizationChanged overwrites any union data inside the ParticipantEvent as the provided ParticipantAuthorizationChanged
func (t *ParticipantEvent) FromParticipantAuthorizationChanged(v ParticipantAuthorizationChanged) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantAuthorizationChanged performs a merge with any union data inside the ParticipantEvent, using the provided ParticipantAuthorizationChanged
func (t *ParticipantEvent) MergeParticipantAuthorizationChanged(v ParticipantAuthorizationChanged) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParticipantAuthorizationRevoked returns the union data inside the ParticipantEvent as a ParticipantAuthorizationRevoked
func (t ParticipantEvent) AsParticipantAuthorizationRevoked() (ParticipantAuthorizationRevoked, error) {
	var body ParticipantAuthorizationRevoked
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantAuthorizationRevoked overwrites any union data inside the ParticipantEvent as the provided ParticipantAuthorizationRevoked
func (t *ParticipantEvent) FromParticipantAuthorizationRevoked(v ParticipantAuthorizationRevoked) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantAuthorizationRevoked performs a merge with any union data inside the ParticipantEvent, using the provided ParticipantAuthorizationRevoked
func (t *ParticipantEvent) MergeParticipantAuthorizationRevoked(v ParticipantAuthorizationRevoked) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParticipantEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParticipantEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHashingSchemeVersion0 returns the union data inside the HashingSchemeVersion as a HashingSchemeVersion0
func (t HashingSchemeVersion) AsHashingSchemeVersion0() (HashingSchemeVersion0, error) {
	var body HashingSchemeVersion0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHashingSchemeVersion0 overwrites any union data inside the HashingSchemeVersion as the provided HashingSchemeVersion0
func (t *HashingSchemeVersion) FromHashingSchemeVersion0(v HashingSchemeVersion0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHashingSchemeVersion0 performs a merge with any union data inside the HashingSchemeVersion, using the provided HashingSchemeVersion0
func (t *HashingSchemeVersion) MergeHashingSchemeVersion0(v HashingSchemeVersion0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHashingSchemeVersion1 returns the union data inside the HashingSchemeVersion as a HashingSchemeVersion1
func (t HashingSchemeVersion) AsHashingSchemeVersion1() (HashingSchemeVersion1, error) {
	var body HashingSchemeVersion1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHashingSchemeVersion1 overwrites any union data inside the HashingSchemeVersion as the provided HashingSchemeVersion1
func (t *HashingSchemeVersion) FromHashingSchemeVersion1(v HashingSchemeVersion1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHashingSchemeVersion1 performs a merge with any union data inside the HashingSchemeVersion, using the provided HashingSchemeVersion1
func (t *HashingSchemeVersion) MergeHashingSchemeVersion1(v HashingSchemeVersion1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHashingSchemeVersion2 returns the union data inside the HashingSchemeVersion as a HashingSchemeVersion2
func (t HashingSchemeVersion) AsHashingSchemeVersion2() (HashingSchemeVersion2, error) {
	var body HashingSchemeVersion2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHashingSchemeVersion2 overwrites any union data inside the HashingSchemeVersion as the provided HashingSchemeVersion2
func (t *HashingSchemeVersion) FromHashingSchemeVersion2(v HashingSchemeVersion2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHashingSchemeVersion2 performs a merge with any union data inside the HashingSchemeVersion, using the provided HashingSchemeVersion2
func (t *HashingSchemeVersion) MergeHashingSchemeVersion2(v HashingSchemeVersion2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHashingSchemeVersion3 returns the union data inside the HashingSchemeVersion as a HashingSchemeVersion3
func (t HashingSchemeVersion) AsHashingSchemeVersion3() (HashingSchemeVersion3, error) {
	var body HashingSchemeVersion3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHashingSchemeVersion3 overwrites any union data inside the HashingSchemeVersion as the provided HashingSchemeVersion3
func (t *HashingSchemeVersion) FromHashingSchemeVersion3(v HashingSchemeVersion3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHashingSchemeVersion3 performs a merge with any union data inside the HashingSchemeVersion, using the provided HashingSchemeVersion3
func (t *HashingSchemeVersion) MergeHashingSchemeVersion3(v HashingSchemeVersion3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t HashingSchemeVersion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *HashingSchemeVersion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIdentifierFilter0 returns the union data inside the IdentifierFilter as a IdentifierFilter0
func (t IdentifierFilter) AsIdentifierFilter0() (IdentifierFilter0, error) {
	var body IdentifierFilter0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentifierFilter0 overwrites any union data inside the IdentifierFilter as the provided IdentifierFilter0
func (t *IdentifierFilter) FromIdentifierFilter0(v IdentifierFilter0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentifierFilter0 performs a merge with any union data inside the IdentifierFilter, using the provided IdentifierFilter0
func (t *IdentifierFilter) MergeIdentifierFilter0(v IdentifierFilter0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentifierFilter1 returns the union data inside the IdentifierFilter as a IdentifierFilter1
func (t IdentifierFilter) AsIdentifierFilter1() (IdentifierFilter1, error) {
	var body IdentifierFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentifierFilter1 overwrites any union data inside the IdentifierFilter as the provided IdentifierFilter1
func (t *IdentifierFilter) FromIdentifierFilter1(v IdentifierFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentifierFilter1 performs a merge with any union data inside the IdentifierFilter, using the provided IdentifierFilter1
func (t *IdentifierFilter) MergeIdentifierFilter1(v IdentifierFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentifierFilter2 returns the union data inside the IdentifierFilter as a IdentifierFilter2
func (t IdentifierFilter) AsIdentifierFilter2() (IdentifierFilter2, error) {
	var body IdentifierFilter2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentifierFilter2 overwrites any union data inside the IdentifierFilter as the provided IdentifierFilter2
func (t *IdentifierFilter) FromIdentifierFilter2(v IdentifierFilter2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentifierFilter2 performs a merge with any union data inside the IdentifierFilter, using the provided IdentifierFilter2
func (t *IdentifierFilter) MergeIdentifierFilter2(v IdentifierFilter2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentifierFilter3 returns the union data inside the IdentifierFilter as a IdentifierFilter3
func (t IdentifierFilter) AsIdentifierFilter3() (IdentifierFilter3, error) {
	var body IdentifierFilter3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentifierFilter3 overwrites any union data inside the IdentifierFilter as the provided IdentifierFilter3
func (t *IdentifierFilter) FromIdentifierFilter3(v IdentifierFilter3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentifierFilter3 performs a merge with any union data inside the IdentifierFilter, using the provided IdentifierFilter3
func (t *IdentifierFilter) MergeIdentifierFilter3(v IdentifierFilter3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IdentifierFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IdentifierFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJsContractEntry0 returns the union data inside the JsContractEntry as a JsContractEntry0
func (t JsContractEntry) AsJsContractEntry0() (JsContractEntry0, error) {
	var body JsContractEntry0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsContractEntry0 overwrites any union data inside the JsContractEntry as the provided JsContractEntry0
func (t *JsContractEntry) FromJsContractEntry0(v JsContractEntry0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsContractEntry0 performs a merge with any union data inside the JsContractEntry, using the provided JsContractEntry0
func (t *JsContractEntry) MergeJsContractEntry0(v JsContractEntry0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsContractEntry1 returns the union data inside the JsContractEntry as a JsContractEntry1
func (t JsContractEntry) AsJsContractEntry1() (JsContractEntry1, error) {
	var body JsContractEntry1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsContractEntry1 overwrites any union data inside the JsContractEntry as the provided JsContractEntry1
func (t *JsContractEntry) FromJsContractEntry1(v JsContractEntry1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsContractEntry1 performs a merge with any union data inside the JsContractEntry, using the provided JsContractEntry1
func (t *JsContractEntry) MergeJsContractEntry1(v JsContractEntry1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsContractEntry2 returns the union data inside the JsContractEntry as a JsContractEntry2
func (t JsContractEntry) AsJsContractEntry2() (JsContractEntry2, error) {
	var body JsContractEntry2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsContractEntry2 overwrites any union data inside the JsContractEntry as the provided JsContractEntry2
func (t *JsContractEntry) FromJsContractEntry2(v JsContractEntry2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsContractEntry2 performs a merge with any union data inside the JsContractEntry, using the provided JsContractEntry2
func (t *JsContractEntry) MergeJsContractEntry2(v JsContractEntry2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsContractEntry3 returns the union data inside the JsContractEntry as a JsContractEntry3
func (t JsContractEntry) AsJsContractEntry3() (JsContractEntry3, error) {
	var body JsContractEntry3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsContractEntry3 overwrites any union data inside the JsContractEntry as the provided JsContractEntry3
func (t *JsContractEntry) FromJsContractEntry3(v JsContractEntry3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsContractEntry3 performs a merge with any union data inside the JsContractEntry, using the provided JsContractEntry3
func (t *JsContractEntry) MergeJsContractEntry3(v JsContractEntry3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JsContractEntry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JsContractEntry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJsAssignmentEvent returns the union data inside the JsReassignmentEvent as a JsAssignmentEvent
func (t JsReassignmentEvent) AsJsAssignmentEvent() (JsAssignmentEvent, error) {
	var body JsAssignmentEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsAssignmentEvent overwrites any union data inside the JsReassignmentEvent as the provided JsAssignmentEvent
func (t *JsReassignmentEvent) FromJsAssignmentEvent(v JsAssignmentEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsAssignmentEvent performs a merge with any union data inside the JsReassignmentEvent, using the provided JsAssignmentEvent
func (t *JsReassignmentEvent) MergeJsAssignmentEvent(v JsAssignmentEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsUnassignedEvent returns the union data inside the JsReassignmentEvent as a JsUnassignedEvent
func (t JsReassignmentEvent) AsJsUnassignedEvent() (JsUnassignedEvent, error) {
	var body JsUnassignedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsUnassignedEvent overwrites any union data inside the JsReassignmentEvent as the provided JsUnassignedEvent
func (t *JsReassignmentEvent) FromJsUnassignedEvent(v JsUnassignedEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsUnassignedEvent performs a merge with any union data inside the JsReassignmentEvent, using the provided JsUnassignedEvent
func (t *JsReassignmentEvent) MergeJsUnassignedEvent(v JsUnassignedEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JsReassignmentEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JsReassignmentEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKind0 returns the union data inside the Kind as a Kind0
func (t Kind) AsKind0() (Kind0, error) {
	var body Kind0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKind0 overwrites any union data inside the Kind as the provided Kind0
func (t *Kind) FromKind0(v Kind0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKind0 performs a merge with any union data inside the Kind, using the provided Kind0
func (t *Kind) MergeKind0(v Kind0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKind1 returns the union data inside the Kind as a Kind1
func (t Kind) AsKind1() (Kind1, error) {
	var body Kind1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKind1 overwrites any union data inside the Kind as the provided Kind1
func (t *Kind) FromKind1(v Kind1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKind1 performs a merge with any union data inside the Kind, using the provided Kind1
func (t *Kind) MergeKind1(v Kind1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKind2 returns the union data inside the Kind as a Kind2
func (t Kind) AsKind2() (Kind2, error) {
	var body Kind2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKind2 overwrites any union data inside the Kind as the provided Kind2
func (t *Kind) FromKind2(v Kind2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKind2 performs a merge with any union data inside the Kind, using the provided Kind2
func (t *Kind) MergeKind2(v Kind2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKind3 returns the union data inside the Kind as a Kind3
func (t Kind) AsKind3() (Kind3, error) {
	var body Kind3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKind3 overwrites any union data inside the Kind as the provided Kind3
func (t *Kind) FromKind3(v Kind3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKind3 performs a merge with any union data inside the Kind, using the provided Kind3
func (t *Kind) MergeKind3(v Kind3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKind4 returns the union data inside the Kind as a Kind4
func (t Kind) AsKind4() (Kind4, error) {
	var body Kind4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKind4 overwrites any union data inside the Kind as the provided Kind4
func (t *Kind) FromKind4(v Kind4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKind4 performs a merge with any union data inside the Kind, using the provided Kind4
func (t *Kind) MergeKind4(v Kind4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKind5 returns the union data inside the Kind as a Kind5
func (t Kind) AsKind5() (Kind5, error) {
	var body Kind5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKind5 overwrites any union data inside the Kind as the provided Kind5
func (t *Kind) FromKind5(v Kind5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKind5 performs a merge with any union data inside the Kind, using the provided Kind5
func (t *Kind) MergeKind5(v Kind5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Kind) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Kind) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageStatus0 returns the union data inside the PackageStatus as a PackageStatus0
func (t PackageStatus) AsPackageStatus0() (PackageStatus0, error) {
	var body PackageStatus0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageStatus0 overwrites any union data inside the PackageStatus as the provided PackageStatus0
func (t *PackageStatus) FromPackageStatus0(v PackageStatus0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageStatus0 performs a merge with any union data inside the PackageStatus, using the provided PackageStatus0
func (t *PackageStatus) MergePackageStatus0(v PackageStatus0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageStatus1 returns the union data inside the PackageStatus as a PackageStatus1
func (t PackageStatus) AsPackageStatus1() (PackageStatus1, error) {
	var body PackageStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageStatus1 overwrites any union data inside the PackageStatus as the provided PackageStatus1
func (t *PackageStatus) FromPackageStatus1(v PackageStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageStatus1 performs a merge with any union data inside the PackageStatus, using the provided PackageStatus1
func (t *PackageStatus) MergePackageStatus1(v PackageStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageStatus2 returns the union data inside the PackageStatus as a PackageStatus2
func (t PackageStatus) AsPackageStatus2() (PackageStatus2, error) {
	var body PackageStatus2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageStatus2 overwrites any union data inside the PackageStatus as the provided PackageStatus2
func (t *PackageStatus) FromPackageStatus2(v PackageStatus2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageStatus2 performs a merge with any union data inside the PackageStatus, using the provided PackageStatus2
func (t *PackageStatus) MergePackageStatus2(v PackageStatus2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageStatus3 returns the union data inside the PackageStatus as a PackageStatus3
func (t PackageStatus) AsPackageStatus3() (PackageStatus3, error) {
	var body PackageStatus3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageStatus3 overwrites any union data inside the PackageStatus as the provided PackageStatus3
func (t *PackageStatus) FromPackageStatus3(v PackageStatus3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageStatus3 performs a merge with any union data inside the PackageStatus, using the provided PackageStatus3
func (t *PackageStatus) MergePackageStatus3(v PackageStatus3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParticipantPermission0 returns the union data inside the ParticipantPermission as a ParticipantPermission0
func (t ParticipantPermission) AsParticipantPermission0() (ParticipantPermission0, error) {
	var body ParticipantPermission0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantPermission0 overwrites any union data inside the ParticipantPermission as the provided ParticipantPermission0
func (t *ParticipantPermission) FromParticipantPermission0(v ParticipantPermission0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantPermission0 performs a merge with any union data inside the ParticipantPermission, using the provided ParticipantPermission0
func (t *ParticipantPermission) MergeParticipantPermission0(v ParticipantPermission0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParticipantPermission1 returns the union data inside the ParticipantPermission as a ParticipantPermission1
func (t ParticipantPermission) AsParticipantPermission1() (ParticipantPermission1, error) {
	var body ParticipantPermission1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantPermission1 overwrites any union data inside the ParticipantPermission as the provided ParticipantPermission1
func (t *ParticipantPermission) FromParticipantPermission1(v ParticipantPermission1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantPermission1 performs a merge with any union data inside the ParticipantPermission, using the provided ParticipantPermission1
func (t *ParticipantPermission) MergeParticipantPermission1(v ParticipantPermission1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParticipantPermission2 returns the union data inside the ParticipantPermission as a ParticipantPermission2
func (t ParticipantPermission) AsParticipantPermission2() (ParticipantPermission2, error) {
	var body ParticipantPermission2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantPermission2 overwrites any union data inside the ParticipantPermission as the provided ParticipantPermission2
func (t *ParticipantPermission) FromParticipantPermission2(v ParticipantPermission2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantPermission2 performs a merge with any union data inside the ParticipantPermission, using the provided ParticipantPermission2
func (t *ParticipantPermission) MergeParticipantPermission2(v ParticipantPermission2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParticipantPermission3 returns the union data inside the ParticipantPermission as a ParticipantPermission3
func (t ParticipantPermission) AsParticipantPermission3() (ParticipantPermission3, error) {
	var body ParticipantPermission3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantPermission3 overwrites any union data inside the ParticipantPermission as the provided ParticipantPermission3
func (t *ParticipantPermission) FromParticipantPermission3(v ParticipantPermission3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantPermission3 performs a merge with any union data inside the ParticipantPermission, using the provided ParticipantPermission3
func (t *ParticipantPermission) MergeParticipantPermission3(v ParticipantPermission3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParticipantPermission4 returns the union data inside the ParticipantPermission as a ParticipantPermission4
func (t ParticipantPermission) AsParticipantPermission4() (ParticipantPermission4, error) {
	var body ParticipantPermission4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantPermission4 overwrites any union data inside the ParticipantPermission as the provided ParticipantPermission4
func (t *ParticipantPermission) FromParticipantPermission4(v ParticipantPermission4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantPermission4 performs a merge with any union data inside the ParticipantPermission, using the provided ParticipantPermission4
func (t *ParticipantPermission) MergeParticipantPermission4(v ParticipantPermission4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParticipantPermission5 returns the union data inside the ParticipantPermission as a ParticipantPermission5
func (t ParticipantPermission) AsParticipantPermission5() (ParticipantPermission5, error) {
	var body ParticipantPermission5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParticipantPermission5 overwrites any union data inside the ParticipantPermission as the provided ParticipantPermission5
func (t *ParticipantPermission) FromParticipantPermission5(v ParticipantPermission5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParticipantPermission5 performs a merge with any union data inside the ParticipantPermission, using the provided ParticipantPermission5
func (t *ParticipantPermission) MergeParticipantPermission5(v ParticipantPermission5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParticipantPermission) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParticipantPermission) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRecognized0 returns the union data inside the Recognized as a Recognized0
func (t Recognized) AsRecognized0() (Recognized0, error) {
	var body Recognized0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecognized0 overwrites any union data inside the Recognized as the provided Recognized0
func (t *Recognized) FromRecognized0(v Recognized0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecognized0 performs a merge with any union data inside the Recognized, using the provided Recognized0
func (t *Recognized) MergeRecognized0(v Recognized0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRecognized1 returns the union data inside the Recognized as a Recognized1
func (t Recognized) AsRecognized1() (Recognized1, error) {
	var body Recognized1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecognized1 overwrites any union data inside the Recognized as the provided Recognized1
func (t *Recognized) FromRecognized1(v Recognized1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecognized1 performs a merge with any union data inside the Recognized, using the provided Recognized1
func (t *Recognized) MergeRecognized1(v Recognized1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Recognized) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Recognized) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRecognized10 returns the union data inside the ParticipantPermissionRecognized as a Recognized10
func (t ParticipantPermissionRecognized) AsRecognized10() (Recognized10, error) {
	var body Recognized10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecognized10 overwrites any union data inside the ParticipantPermissionRecognized as the provided Recognized10
func (t *ParticipantPermissionRecognized) FromRecognized10(v Recognized10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecognized10 performs a merge with any union data inside the ParticipantPermissionRecognized, using the provided Recognized10
func (t *ParticipantPermissionRecognized) MergeRecognized10(v Recognized10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRecognized11 returns the union data inside the ParticipantPermissionRecognized as a Recognized11
func (t ParticipantPermissionRecognized) AsRecognized11() (Recognized11, error) {
	var body Recognized11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecognized11 overwrites any union data inside the ParticipantPermissionRecognized as the provided Recognized11
func (t *ParticipantPermissionRecognized) FromRecognized11(v Recognized11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecognized11 performs a merge with any union data inside the ParticipantPermissionRecognized, using the provided Recognized11
func (t *ParticipantPermissionRecognized) MergeRecognized11(v Recognized11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRecognized12 returns the union data inside the ParticipantPermissionRecognized as a Recognized12
func (t ParticipantPermissionRecognized) AsRecognized12() (Recognized12, error) {
	var body Recognized12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecognized12 overwrites any union data inside the ParticipantPermissionRecognized as the provided Recognized12
func (t *ParticipantPermissionRecognized) FromRecognized12(v Recognized12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecognized12 performs a merge with any union data inside the ParticipantPermissionRecognized, using the provided Recognized12
func (t *ParticipantPermissionRecognized) MergeRecognized12(v Recognized12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRecognized13 returns the union data inside the ParticipantPermissionRecognized as a Recognized13
func (t ParticipantPermissionRecognized) AsRecognized13() (Recognized13, error) {
	var body Recognized13
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecognized13 overwrites any union data inside the ParticipantPermissionRecognized as the provided Recognized13
func (t *ParticipantPermissionRecognized) FromRecognized13(v Recognized13) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecognized13 performs a merge with any union data inside the ParticipantPermissionRecognized, using the provided Recognized13
func (t *ParticipantPermissionRecognized) MergeRecognized13(v Recognized13) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParticipantPermissionRecognized) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParticipantPermissionRecognized) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHASHINGSCHEMEVERSIONUNSPECIFIED returns the union data inside the Recognized2 as a HASHINGSCHEMEVERSIONUNSPECIFIED
func (t Recognized2) AsHASHINGSCHEMEVERSIONUNSPECIFIED() (HASHINGSCHEMEVERSIONUNSPECIFIED, error) {
	var body HASHINGSCHEMEVERSIONUNSPECIFIED
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHASHINGSCHEMEVERSIONUNSPECIFIED overwrites any union data inside the Recognized2 as the provided HASHINGSCHEMEVERSIONUNSPECIFIED
func (t *Recognized2) FromHASHINGSCHEMEVERSIONUNSPECIFIED(v HASHINGSCHEMEVERSIONUNSPECIFIED) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHASHINGSCHEMEVERSIONUNSPECIFIED performs a merge with any union data inside the Recognized2, using the provided HASHINGSCHEMEVERSIONUNSPECIFIED
func (t *Recognized2) MergeHASHINGSCHEMEVERSIONUNSPECIFIED(v HASHINGSCHEMEVERSIONUNSPECIFIED) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHASHINGSCHEMEVERSIONV2 returns the union data inside the Recognized2 as a HASHINGSCHEMEVERSIONV2
func (t Recognized2) AsHASHINGSCHEMEVERSIONV2() (HASHINGSCHEMEVERSIONV2, error) {
	var body HASHINGSCHEMEVERSIONV2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHASHINGSCHEMEVERSIONV2 overwrites any union data inside the Recognized2 as the provided HASHINGSCHEMEVERSIONV2
func (t *Recognized2) FromHASHINGSCHEMEVERSIONV2(v HASHINGSCHEMEVERSIONV2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHASHINGSCHEMEVERSIONV2 performs a merge with any union data inside the Recognized2, using the provided HASHINGSCHEMEVERSIONV2
func (t *Recognized2) MergeHASHINGSCHEMEVERSIONV2(v HASHINGSCHEMEVERSIONV2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Recognized2) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Recognized2) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSIGNATUREFORMATCONCAT returns the union data inside the SignatureFormat as a SIGNATUREFORMATCONCAT
func (t SignatureFormat) AsSIGNATUREFORMATCONCAT() (SIGNATUREFORMATCONCAT, error) {
	var body SIGNATUREFORMATCONCAT
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNATUREFORMATCONCAT overwrites any union data inside the SignatureFormat as the provided SIGNATUREFORMATCONCAT
func (t *SignatureFormat) FromSIGNATUREFORMATCONCAT(v SIGNATUREFORMATCONCAT) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNATUREFORMATCONCAT performs a merge with any union data inside the SignatureFormat, using the provided SIGNATUREFORMATCONCAT
func (t *SignatureFormat) MergeSIGNATUREFORMATCONCAT(v SIGNATUREFORMATCONCAT) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSIGNATUREFORMATDER returns the union data inside the SignatureFormat as a SIGNATUREFORMATDER
func (t SignatureFormat) AsSIGNATUREFORMATDER() (SIGNATUREFORMATDER, error) {
	var body SIGNATUREFORMATDER
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNATUREFORMATDER overwrites any union data inside the SignatureFormat as the provided SIGNATUREFORMATDER
func (t *SignatureFormat) FromSIGNATUREFORMATDER(v SIGNATUREFORMATDER) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNATUREFORMATDER performs a merge with any union data inside the SignatureFormat, using the provided SIGNATUREFORMATDER
func (t *SignatureFormat) MergeSIGNATUREFORMATDER(v SIGNATUREFORMATDER) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSIGNATUREFORMATRAW returns the union data inside the SignatureFormat as a SIGNATUREFORMATRAW
func (t SignatureFormat) AsSIGNATUREFORMATRAW() (SIGNATUREFORMATRAW, error) {
	var body SIGNATUREFORMATRAW
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNATUREFORMATRAW overwrites any union data inside the SignatureFormat as the provided SIGNATUREFORMATRAW
func (t *SignatureFormat) FromSIGNATUREFORMATRAW(v SIGNATUREFORMATRAW) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNATUREFORMATRAW performs a merge with any union data inside the SignatureFormat, using the provided SIGNATUREFORMATRAW
func (t *SignatureFormat) MergeSIGNATUREFORMATRAW(v SIGNATUREFORMATRAW) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSIGNATUREFORMATSYMBOLIC returns the union data inside the SignatureFormat as a SIGNATUREFORMATSYMBOLIC
func (t SignatureFormat) AsSIGNATUREFORMATSYMBOLIC() (SIGNATUREFORMATSYMBOLIC, error) {
	var body SIGNATUREFORMATSYMBOLIC
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNATUREFORMATSYMBOLIC overwrites any union data inside the SignatureFormat as the provided SIGNATUREFORMATSYMBOLIC
func (t *SignatureFormat) FromSIGNATUREFORMATSYMBOLIC(v SIGNATUREFORMATSYMBOLIC) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNATUREFORMATSYMBOLIC performs a merge with any union data inside the SignatureFormat, using the provided SIGNATUREFORMATSYMBOLIC
func (t *SignatureFormat) MergeSIGNATUREFORMATSYMBOLIC(v SIGNATUREFORMATSYMBOLIC) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSIGNATUREFORMATUNSPECIFIED returns the union data inside the SignatureFormat as a SIGNATUREFORMATUNSPECIFIED
func (t SignatureFormat) AsSIGNATUREFORMATUNSPECIFIED() (SIGNATUREFORMATUNSPECIFIED, error) {
	var body SIGNATUREFORMATUNSPECIFIED
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNATUREFORMATUNSPECIFIED overwrites any union data inside the SignatureFormat as the provided SIGNATUREFORMATUNSPECIFIED
func (t *SignatureFormat) FromSIGNATUREFORMATUNSPECIFIED(v SIGNATUREFORMATUNSPECIFIED) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNATUREFORMATUNSPECIFIED performs a merge with any union data inside the SignatureFormat, using the provided SIGNATUREFORMATUNSPECIFIED
func (t *SignatureFormat) MergeSIGNATUREFORMATUNSPECIFIED(v SIGNATUREFORMATUNSPECIFIED) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnrecognized4 returns the union data inside the SignatureFormat as a Unrecognized4
func (t SignatureFormat) AsUnrecognized4() (Unrecognized4, error) {
	var body Unrecognized4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnrecognized4 overwrites any union data inside the SignatureFormat as the provided Unrecognized4
func (t *SignatureFormat) FromUnrecognized4(v Unrecognized4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnrecognized4 performs a merge with any union data inside the SignatureFormat, using the provided Unrecognized4
func (t *SignatureFormat) MergeUnrecognized4(v Unrecognized4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignatureFormat) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignatureFormat) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSIGNINGALGORITHMSPECECDSASHA256 returns the union data inside the SigningAlgorithmSpec as a SIGNINGALGORITHMSPECECDSASHA256
func (t SigningAlgorithmSpec) AsSIGNINGALGORITHMSPECECDSASHA256() (SIGNINGALGORITHMSPECECDSASHA256, error) {
	var body SIGNINGALGORITHMSPECECDSASHA256
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNINGALGORITHMSPECECDSASHA256 overwrites any union data inside the SigningAlgorithmSpec as the provided SIGNINGALGORITHMSPECECDSASHA256
func (t *SigningAlgorithmSpec) FromSIGNINGALGORITHMSPECECDSASHA256(v SIGNINGALGORITHMSPECECDSASHA256) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNINGALGORITHMSPECECDSASHA256 performs a merge with any union data inside the SigningAlgorithmSpec, using the provided SIGNINGALGORITHMSPECECDSASHA256
func (t *SigningAlgorithmSpec) MergeSIGNINGALGORITHMSPECECDSASHA256(v SIGNINGALGORITHMSPECECDSASHA256) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSIGNINGALGORITHMSPECECDSASHA384 returns the union data inside the SigningAlgorithmSpec as a SIGNINGALGORITHMSPECECDSASHA384
func (t SigningAlgorithmSpec) AsSIGNINGALGORITHMSPECECDSASHA384() (SIGNINGALGORITHMSPECECDSASHA384, error) {
	var body SIGNINGALGORITHMSPECECDSASHA384
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNINGALGORITHMSPECECDSASHA384 overwrites any union data inside the SigningAlgorithmSpec as the provided SIGNINGALGORITHMSPECECDSASHA384
func (t *SigningAlgorithmSpec) FromSIGNINGALGORITHMSPECECDSASHA384(v SIGNINGALGORITHMSPECECDSASHA384) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNINGALGORITHMSPECECDSASHA384 performs a merge with any union data inside the SigningAlgorithmSpec, using the provided SIGNINGALGORITHMSPECECDSASHA384
func (t *SigningAlgorithmSpec) MergeSIGNINGALGORITHMSPECECDSASHA384(v SIGNINGALGORITHMSPECECDSASHA384) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSIGNINGALGORITHMSPECED25519 returns the union data inside the SigningAlgorithmSpec as a SIGNINGALGORITHMSPECED25519
func (t SigningAlgorithmSpec) AsSIGNINGALGORITHMSPECED25519() (SIGNINGALGORITHMSPECED25519, error) {
	var body SIGNINGALGORITHMSPECED25519
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNINGALGORITHMSPECED25519 overwrites any union data inside the SigningAlgorithmSpec as the provided SIGNINGALGORITHMSPECED25519
func (t *SigningAlgorithmSpec) FromSIGNINGALGORITHMSPECED25519(v SIGNINGALGORITHMSPECED25519) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNINGALGORITHMSPECED25519 performs a merge with any union data inside the SigningAlgorithmSpec, using the provided SIGNINGALGORITHMSPECED25519
func (t *SigningAlgorithmSpec) MergeSIGNINGALGORITHMSPECED25519(v SIGNINGALGORITHMSPECED25519) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSIGNINGALGORITHMSPECUNSPECIFIED returns the union data inside the SigningAlgorithmSpec as a SIGNINGALGORITHMSPECUNSPECIFIED
func (t SigningAlgorithmSpec) AsSIGNINGALGORITHMSPECUNSPECIFIED() (SIGNINGALGORITHMSPECUNSPECIFIED, error) {
	var body SIGNINGALGORITHMSPECUNSPECIFIED
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIGNINGALGORITHMSPECUNSPECIFIED overwrites any union data inside the SigningAlgorithmSpec as the provided SIGNINGALGORITHMSPECUNSPECIFIED
func (t *SigningAlgorithmSpec) FromSIGNINGALGORITHMSPECUNSPECIFIED(v SIGNINGALGORITHMSPECUNSPECIFIED) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIGNINGALGORITHMSPECUNSPECIFIED performs a merge with any union data inside the SigningAlgorithmSpec, using the provided SIGNINGALGORITHMSPECUNSPECIFIED
func (t *SigningAlgorithmSpec) MergeSIGNINGALGORITHMSPECUNSPECIFIED(v SIGNINGALGORITHMSPECUNSPECIFIED) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnrecognized5 returns the union data inside the SigningAlgorithmSpec as a Unrecognized5
func (t SigningAlgorithmSpec) AsUnrecognized5() (Unrecognized5, error) {
	var body Unrecognized5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnrecognized5 overwrites any union data inside the SigningAlgorithmSpec as the provided Unrecognized5
func (t *SigningAlgorithmSpec) FromUnrecognized5(v Unrecognized5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnrecognized5 performs a merge with any union data inside the SigningAlgorithmSpec, using the provided Unrecognized5
func (t *SigningAlgorithmSpec) MergeUnrecognized5(v Unrecognized5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SigningAlgorithmSpec) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SigningAlgorithmSpec) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTime0 returns the union data inside the Time as a Time0
func (t Time) AsTime0() (Time0, error) {
	var body Time0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTime0 overwrites any union data inside the Time as the provided Time0
func (t *Time) FromTime0(v Time0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTime0 performs a merge with any union data inside the Time, using the provided Time0
func (t *Time) MergeTime0(v Time0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTime1 returns the union data inside the Time as a Time1
func (t Time) AsTime1() (Time1, error) {
	var body Time1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTime1 overwrites any union data inside the Time as the provided Time1
func (t *Time) FromTime1(v Time1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTime1 performs a merge with any union data inside the Time, using the provided Time1
func (t *Time) MergeTime1(v Time1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTime2 returns the union data inside the Time as a Time2
func (t Time) AsTime2() (Time2, error) {
	var body Time2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTime2 overwrites any union data inside the Time as the provided Time2
func (t *Time) FromTime2(v Time2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTime2 performs a merge with any union data inside the Time, using the provided Time2
func (t *Time) MergeTime2(v Time2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Time) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Time) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTRANSACTIONSHAPEACSDELTA returns the union data inside the TransactionShape as a TRANSACTIONSHAPEACSDELTA
func (t TransactionShape) AsTRANSACTIONSHAPEACSDELTA() (TRANSACTIONSHAPEACSDELTA, error) {
	var body TRANSACTIONSHAPEACSDELTA
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTRANSACTIONSHAPEACSDELTA overwrites any union data inside the TransactionShape as the provided TRANSACTIONSHAPEACSDELTA
func (t *TransactionShape) FromTRANSACTIONSHAPEACSDELTA(v TRANSACTIONSHAPEACSDELTA) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTRANSACTIONSHAPEACSDELTA performs a merge with any union data inside the TransactionShape, using the provided TRANSACTIONSHAPEACSDELTA
func (t *TransactionShape) MergeTRANSACTIONSHAPEACSDELTA(v TRANSACTIONSHAPEACSDELTA) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTRANSACTIONSHAPELEDGEREFFECTS returns the union data inside the TransactionShape as a TRANSACTIONSHAPELEDGEREFFECTS
func (t TransactionShape) AsTRANSACTIONSHAPELEDGEREFFECTS() (TRANSACTIONSHAPELEDGEREFFECTS, error) {
	var body TRANSACTIONSHAPELEDGEREFFECTS
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTRANSACTIONSHAPELEDGEREFFECTS overwrites any union data inside the TransactionShape as the provided TRANSACTIONSHAPELEDGEREFFECTS
func (t *TransactionShape) FromTRANSACTIONSHAPELEDGEREFFECTS(v TRANSACTIONSHAPELEDGEREFFECTS) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTRANSACTIONSHAPELEDGEREFFECTS performs a merge with any union data inside the TransactionShape, using the provided TRANSACTIONSHAPELEDGEREFFECTS
func (t *TransactionShape) MergeTRANSACTIONSHAPELEDGEREFFECTS(v TRANSACTIONSHAPELEDGEREFFECTS) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTRANSACTIONSHAPEUNSPECIFIED returns the union data inside the TransactionShape as a TRANSACTIONSHAPEUNSPECIFIED
func (t TransactionShape) AsTRANSACTIONSHAPEUNSPECIFIED() (TRANSACTIONSHAPEUNSPECIFIED, error) {
	var body TRANSACTIONSHAPEUNSPECIFIED
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTRANSACTIONSHAPEUNSPECIFIED overwrites any union data inside the TransactionShape as the provided TRANSACTIONSHAPEUNSPECIFIED
func (t *TransactionShape) FromTRANSACTIONSHAPEUNSPECIFIED(v TRANSACTIONSHAPEUNSPECIFIED) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTRANSACTIONSHAPEUNSPECIFIED performs a merge with any union data inside the TransactionShape, using the provided TRANSACTIONSHAPEUNSPECIFIED
func (t *TransactionShape) MergeTRANSACTIONSHAPEUNSPECIFIED(v TRANSACTIONSHAPEUNSPECIFIED) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnrecognized returns the union data inside the TransactionShape as a Unrecognized
func (t TransactionShape) AsUnrecognized() (Unrecognized, error) {
	var body Unrecognized
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnrecognized overwrites any union data inside the TransactionShape as the provided Unrecognized
func (t *TransactionShape) FromUnrecognized(v Unrecognized) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnrecognized performs a merge with any union data inside the TransactionShape, using the provided Unrecognized
func (t *TransactionShape) MergeUnrecognized(v Unrecognized) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransactionShape) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransactionShape) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTreeEvent0 returns the union data inside the TreeEvent as a TreeEvent0
func (t TreeEvent) AsTreeEvent0() (TreeEvent0, error) {
	var body TreeEvent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTreeEvent0 overwrites any union data inside the TreeEvent as the provided TreeEvent0
func (t *TreeEvent) FromTreeEvent0(v TreeEvent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTreeEvent0 performs a merge with any union data inside the TreeEvent, using the provided TreeEvent0
func (t *TreeEvent) MergeTreeEvent0(v TreeEvent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTreeEvent1 returns the union data inside the TreeEvent as a TreeEvent1
func (t TreeEvent) AsTreeEvent1() (TreeEvent1, error) {
	var body TreeEvent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTreeEvent1 overwrites any union data inside the TreeEvent as the provided TreeEvent1
func (t *TreeEvent) FromTreeEvent1(v TreeEvent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTreeEvent1 performs a merge with any union data inside the TreeEvent, using the provided TreeEvent1
func (t *TreeEvent) MergeTreeEvent1(v TreeEvent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TreeEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TreeEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdate0 returns the union data inside the Update as a Update0
func (t Update) AsUpdate0() (Update0, error) {
	var body Update0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdate0 overwrites any union data inside the Update as the provided Update0
func (t *Update) FromUpdate0(v Update0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdate0 performs a merge with any union data inside the Update, using the provided Update0
func (t *Update) MergeUpdate0(v Update0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdate1 returns the union data inside the Update as a Update1
func (t Update) AsUpdate1() (Update1, error) {
	var body Update1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdate1 overwrites any union data inside the Update as the provided Update1
func (t *Update) FromUpdate1(v Update1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdate1 performs a merge with any union data inside the Update, using the provided Update1
func (t *Update) MergeUpdate1(v Update1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdate2 returns the union data inside the Update as a Update2
func (t Update) AsUpdate2() (Update2, error) {
	var body Update2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdate2 overwrites any union data inside the Update as the provided Update2
func (t *Update) FromUpdate2(v Update2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdate2 performs a merge with any union data inside the Update, using the provided Update2
func (t *Update) MergeUpdate2(v Update2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdate3 returns the union data inside the Update as a Update3
func (t Update) AsUpdate3() (Update3, error) {
	var body Update3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdate3 overwrites any union data inside the Update as the provided Update3
func (t *Update) FromUpdate3(v Update3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdate3 performs a merge with any union data inside the Update, using the provided Update3
func (t *Update) MergeUpdate3(v Update3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Update) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Update) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdate10 returns the union data inside the UpdateUnion as a Update10
func (t UpdateUnion) AsUpdate10() (Update10, error) {
	var body Update10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdate10 overwrites any union data inside the UpdateUnion as the provided Update10
func (t *UpdateUnion) FromUpdate10(v Update10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdate10 performs a merge with any union data inside the UpdateUnion, using the provided Update10
func (t *UpdateUnion) MergeUpdate10(v Update10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdate11 returns the union data inside the UpdateUnion as a Update11
func (t UpdateUnion) AsUpdate11() (Update11, error) {
	var body Update11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdate11 overwrites any union data inside the UpdateUnion as the provided Update11
func (t *UpdateUnion) FromUpdate11(v Update11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdate11 performs a merge with any union data inside the UpdateUnion, using the provided Update11
func (t *UpdateUnion) MergeUpdate11(v Update11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdate12 returns the union data inside the UpdateUnion as a Update12
func (t UpdateUnion) AsUpdate12() (Update12, error) {
	var body Update12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdate12 overwrites any union data inside the UpdateUnion as the provided Update12
func (t *UpdateUnion) FromUpdate12(v Update12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdate12 performs a merge with any union data inside the UpdateUnion, using the provided Update12
func (t *UpdateUnion) MergeUpdate12(v Update12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostV2CommandsAsyncSubmitWithBody request with any body
	PostV2CommandsAsyncSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2CommandsAsyncSubmit(ctx context.Context, body PostV2CommandsAsyncSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2CommandsAsyncSubmitReassignmentWithBody request with any body
	PostV2CommandsAsyncSubmitReassignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2CommandsAsyncSubmitReassignment(ctx context.Context, body PostV2CommandsAsyncSubmitReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2CommandsCompletionsWithBody request with any body
	PostV2CommandsCompletionsWithBody(ctx context.Context, params *PostV2CommandsCompletionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2CommandsCompletions(ctx context.Context, params *PostV2CommandsCompletionsParams, body PostV2CommandsCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2CommandsSubmitAndWaitWithBody request with any body
	PostV2CommandsSubmitAndWaitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2CommandsSubmitAndWait(ctx context.Context, body PostV2CommandsSubmitAndWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2CommandsSubmitAndWaitForReassignmentWithBody request with any body
	PostV2CommandsSubmitAndWaitForReassignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2CommandsSubmitAndWaitForReassignment(ctx context.Context, body PostV2CommandsSubmitAndWaitForReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2CommandsSubmitAndWaitForTransactionWithBody request with any body
	PostV2CommandsSubmitAndWaitForTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2CommandsSubmitAndWaitForTransaction(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2CommandsSubmitAndWaitForTransactionTreeWithBody request with any body
	PostV2CommandsSubmitAndWaitForTransactionTreeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2CommandsSubmitAndWaitForTransactionTree(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2EventsEventsByContractIdWithBody request with any body
	PostV2EventsEventsByContractIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2EventsEventsByContractId(ctx context.Context, body PostV2EventsEventsByContractIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Idps request
	GetV2Idps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2IdpsWithBody request with any body
	PostV2IdpsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Idps(ctx context.Context, body PostV2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteV2IdpsIdpId request
	DeleteV2IdpsIdpId(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2IdpsIdpId request
	GetV2IdpsIdpId(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2IdpsIdpIdWithBody request with any body
	PatchV2IdpsIdpIdWithBody(ctx context.Context, idpId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2IdpsIdpId(ctx context.Context, idpId string, body PatchV2IdpsIdpIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2InteractiveSubmissionExecuteWithBody request with any body
	PostV2InteractiveSubmissionExecuteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InteractiveSubmissionExecute(ctx context.Context, body PostV2InteractiveSubmissionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2InteractiveSubmissionPreferredPackageVersion request
	GetV2InteractiveSubmissionPreferredPackageVersion(ctx context.Context, params *GetV2InteractiveSubmissionPreferredPackageVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2InteractiveSubmissionPrepareWithBody request with any body
	PostV2InteractiveSubmissionPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2InteractiveSubmissionPrepare(ctx context.Context, body PostV2InteractiveSubmissionPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Packages request
	GetV2Packages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2PackagesWithBody request with any body
	PostV2PackagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2PackagesPackageId request
	GetV2PackagesPackageId(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2PackagesPackageIdStatus request
	GetV2PackagesPackageIdStatus(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Parties request
	GetV2Parties(ctx context.Context, params *GetV2PartiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2PartiesWithBody request with any body
	PostV2PartiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Parties(ctx context.Context, body PostV2PartiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2PartiesParticipantId request
	GetV2PartiesParticipantId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2PartiesParty request
	GetV2PartiesParty(ctx context.Context, party string, params *GetV2PartiesPartyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2PartiesPartyWithBody request with any body
	PatchV2PartiesPartyWithBody(ctx context.Context, party string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2PartiesParty(ctx context.Context, party string, body PatchV2PartiesPartyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2StateActiveContractsWithBody request with any body
	PostV2StateActiveContractsWithBody(ctx context.Context, params *PostV2StateActiveContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2StateActiveContracts(ctx context.Context, params *PostV2StateActiveContractsParams, body PostV2StateActiveContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2StateConnectedSynchronizers request
	GetV2StateConnectedSynchronizers(ctx context.Context, params *GetV2StateConnectedSynchronizersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2StateLatestPrunedOffsets request
	GetV2StateLatestPrunedOffsets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2StateLedgerEnd request
	GetV2StateLedgerEnd(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UpdatesFlatsWithBody request with any body
	PostV2UpdatesFlatsWithBody(ctx context.Context, params *PostV2UpdatesFlatsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2UpdatesFlats(ctx context.Context, params *PostV2UpdatesFlatsParams, body PostV2UpdatesFlatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UpdatesTransactionByIdWithBody request with any body
	PostV2UpdatesTransactionByIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2UpdatesTransactionById(ctx context.Context, body PostV2UpdatesTransactionByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UpdatesTransactionByOffsetWithBody request with any body
	PostV2UpdatesTransactionByOffsetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2UpdatesTransactionByOffset(ctx context.Context, body PostV2UpdatesTransactionByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2UpdatesTransactionTreeByIdUpdateId request
	GetV2UpdatesTransactionTreeByIdUpdateId(ctx context.Context, updateId string, params *GetV2UpdatesTransactionTreeByIdUpdateIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2UpdatesTransactionTreeByOffsetOffset request
	GetV2UpdatesTransactionTreeByOffsetOffset(ctx context.Context, offset int64, params *GetV2UpdatesTransactionTreeByOffsetOffsetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UpdatesTreesWithBody request with any body
	PostV2UpdatesTreesWithBody(ctx context.Context, params *PostV2UpdatesTreesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2UpdatesTrees(ctx context.Context, params *PostV2UpdatesTreesParams, body PostV2UpdatesTreesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UpdatesUpdateByIdWithBody request with any body
	PostV2UpdatesUpdateByIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2UpdatesUpdateById(ctx context.Context, body PostV2UpdatesUpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UpdatesUpdateByOffsetWithBody request with any body
	PostV2UpdatesUpdateByOffsetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2UpdatesUpdateByOffset(ctx context.Context, body PostV2UpdatesUpdateByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Users request
	GetV2Users(ctx context.Context, params *GetV2UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UsersWithBody request with any body
	PostV2UsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2Users(ctx context.Context, body PostV2UsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteV2UsersUserId request
	DeleteV2UsersUserId(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2UsersUserId request
	GetV2UsersUserId(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2UsersUserIdWithBody request with any body
	PatchV2UsersUserIdWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2UsersUserId(ctx context.Context, userId string, body PatchV2UsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2UsersUserIdIdentityProviderIdWithBody request with any body
	PatchV2UsersUserIdIdentityProviderIdWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2UsersUserIdIdentityProviderId(ctx context.Context, userId string, body PatchV2UsersUserIdIdentityProviderIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2UsersUserIdRights request
	GetV2UsersUserIdRights(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchV2UsersUserIdRightsWithBody request with any body
	PatchV2UsersUserIdRightsWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchV2UsersUserIdRights(ctx context.Context, userId string, body PatchV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV2UsersUserIdRightsWithBody request with any body
	PostV2UsersUserIdRightsWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV2UsersUserIdRights(ctx context.Context, userId string, body PostV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2Version request
	GetV2Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostV2CommandsAsyncSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsAsyncSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsAsyncSubmit(ctx context.Context, body PostV2CommandsAsyncSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsAsyncSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsAsyncSubmitReassignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsAsyncSubmitReassignmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsAsyncSubmitReassignment(ctx context.Context, body PostV2CommandsAsyncSubmitReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsAsyncSubmitReassignmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsCompletionsWithBody(ctx context.Context, params *PostV2CommandsCompletionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsCompletionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsCompletions(ctx context.Context, params *PostV2CommandsCompletionsParams, body PostV2CommandsCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsCompletionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWaitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWait(ctx context.Context, body PostV2CommandsSubmitAndWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWaitForReassignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitForReassignmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWaitForReassignment(ctx context.Context, body PostV2CommandsSubmitAndWaitForReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitForReassignmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWaitForTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitForTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWaitForTransaction(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitForTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWaitForTransactionTreeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitForTransactionTreeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2CommandsSubmitAndWaitForTransactionTree(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2CommandsSubmitAndWaitForTransactionTreeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2EventsEventsByContractIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2EventsEventsByContractIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2EventsEventsByContractId(ctx context.Context, body PostV2EventsEventsByContractIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2EventsEventsByContractIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Idps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2IdpsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2IdpsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2IdpsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Idps(ctx context.Context, body PostV2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2IdpsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2IdpsIdpId(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2IdpsIdpIdRequest(c.Server, idpId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2IdpsIdpId(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2IdpsIdpIdRequest(c.Server, idpId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2IdpsIdpIdWithBody(ctx context.Context, idpId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2IdpsIdpIdRequestWithBody(c.Server, idpId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2IdpsIdpId(ctx context.Context, idpId string, body PatchV2IdpsIdpIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2IdpsIdpIdRequest(c.Server, idpId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InteractiveSubmissionExecuteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InteractiveSubmissionExecuteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InteractiveSubmissionExecute(ctx context.Context, body PostV2InteractiveSubmissionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InteractiveSubmissionExecuteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2InteractiveSubmissionPreferredPackageVersion(ctx context.Context, params *GetV2InteractiveSubmissionPreferredPackageVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2InteractiveSubmissionPreferredPackageVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InteractiveSubmissionPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InteractiveSubmissionPrepareRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2InteractiveSubmissionPrepare(ctx context.Context, body PostV2InteractiveSubmissionPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2InteractiveSubmissionPrepareRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Packages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2PackagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2PackagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2PackagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2PackagesPackageId(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2PackagesPackageIdRequest(c.Server, packageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2PackagesPackageIdStatus(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2PackagesPackageIdStatusRequest(c.Server, packageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Parties(ctx context.Context, params *GetV2PartiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2PartiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2PartiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2PartiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Parties(ctx context.Context, body PostV2PartiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2PartiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2PartiesParticipantId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2PartiesParticipantIdRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2PartiesParty(ctx context.Context, party string, params *GetV2PartiesPartyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2PartiesPartyRequest(c.Server, party, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2PartiesPartyWithBody(ctx context.Context, party string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2PartiesPartyRequestWithBody(c.Server, party, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2PartiesParty(ctx context.Context, party string, body PatchV2PartiesPartyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2PartiesPartyRequest(c.Server, party, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2StateActiveContractsWithBody(ctx context.Context, params *PostV2StateActiveContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2StateActiveContractsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2StateActiveContracts(ctx context.Context, params *PostV2StateActiveContractsParams, body PostV2StateActiveContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2StateActiveContractsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2StateConnectedSynchronizers(ctx context.Context, params *GetV2StateConnectedSynchronizersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2StateConnectedSynchronizersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2StateLatestPrunedOffsets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2StateLatestPrunedOffsetsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2StateLedgerEnd(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2StateLedgerEndRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesFlatsWithBody(ctx context.Context, params *PostV2UpdatesFlatsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesFlatsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesFlats(ctx context.Context, params *PostV2UpdatesFlatsParams, body PostV2UpdatesFlatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesFlatsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesTransactionByIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesTransactionByIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesTransactionById(ctx context.Context, body PostV2UpdatesTransactionByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesTransactionByIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesTransactionByOffsetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesTransactionByOffsetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesTransactionByOffset(ctx context.Context, body PostV2UpdatesTransactionByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesTransactionByOffsetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2UpdatesTransactionTreeByIdUpdateId(ctx context.Context, updateId string, params *GetV2UpdatesTransactionTreeByIdUpdateIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2UpdatesTransactionTreeByIdUpdateIdRequest(c.Server, updateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2UpdatesTransactionTreeByOffsetOffset(ctx context.Context, offset int64, params *GetV2UpdatesTransactionTreeByOffsetOffsetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2UpdatesTransactionTreeByOffsetOffsetRequest(c.Server, offset, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesTreesWithBody(ctx context.Context, params *PostV2UpdatesTreesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesTreesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesTrees(ctx context.Context, params *PostV2UpdatesTreesParams, body PostV2UpdatesTreesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesTreesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesUpdateByIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesUpdateByIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesUpdateById(ctx context.Context, body PostV2UpdatesUpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesUpdateByIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesUpdateByOffsetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesUpdateByOffsetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UpdatesUpdateByOffset(ctx context.Context, body PostV2UpdatesUpdateByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UpdatesUpdateByOffsetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Users(ctx context.Context, params *GetV2UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2UsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2Users(ctx context.Context, body PostV2UsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteV2UsersUserId(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteV2UsersUserIdRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2UsersUserId(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2UsersUserIdRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2UsersUserIdWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2UsersUserIdRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2UsersUserId(ctx context.Context, userId string, body PatchV2UsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2UsersUserIdRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2UsersUserIdIdentityProviderIdWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2UsersUserIdIdentityProviderIdRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2UsersUserIdIdentityProviderId(ctx context.Context, userId string, body PatchV2UsersUserIdIdentityProviderIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2UsersUserIdIdentityProviderIdRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2UsersUserIdRights(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2UsersUserIdRightsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2UsersUserIdRightsWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2UsersUserIdRightsRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchV2UsersUserIdRights(ctx context.Context, userId string, body PatchV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchV2UsersUserIdRightsRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UsersUserIdRightsWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UsersUserIdRightsRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV2UsersUserIdRights(ctx context.Context, userId string, body PostV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV2UsersUserIdRightsRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2VersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostV2CommandsAsyncSubmitRequest calls the generic PostV2CommandsAsyncSubmit builder with application/json body
func NewPostV2CommandsAsyncSubmitRequest(server string, body PostV2CommandsAsyncSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2CommandsAsyncSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2CommandsAsyncSubmitRequestWithBody generates requests for PostV2CommandsAsyncSubmit with any type of body
func NewPostV2CommandsAsyncSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/commands/async/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2CommandsAsyncSubmitReassignmentRequest calls the generic PostV2CommandsAsyncSubmitReassignment builder with application/json body
func NewPostV2CommandsAsyncSubmitReassignmentRequest(server string, body PostV2CommandsAsyncSubmitReassignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2CommandsAsyncSubmitReassignmentRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2CommandsAsyncSubmitReassignmentRequestWithBody generates requests for PostV2CommandsAsyncSubmitReassignment with any type of body
func NewPostV2CommandsAsyncSubmitReassignmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/commands/async/submit-reassignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2CommandsCompletionsRequest calls the generic PostV2CommandsCompletions builder with application/json body
func NewPostV2CommandsCompletionsRequest(server string, params *PostV2CommandsCompletionsParams, body PostV2CommandsCompletionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2CommandsCompletionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV2CommandsCompletionsRequestWithBody generates requests for PostV2CommandsCompletions with any type of body
func NewPostV2CommandsCompletionsRequestWithBody(server string, params *PostV2CommandsCompletionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/commands/completions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamIdleTimeoutMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream_idle_timeout_ms", runtime.ParamLocationQuery, *params.StreamIdleTimeoutMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2CommandsSubmitAndWaitRequest calls the generic PostV2CommandsSubmitAndWait builder with application/json body
func NewPostV2CommandsSubmitAndWaitRequest(server string, body PostV2CommandsSubmitAndWaitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2CommandsSubmitAndWaitRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2CommandsSubmitAndWaitRequestWithBody generates requests for PostV2CommandsSubmitAndWait with any type of body
func NewPostV2CommandsSubmitAndWaitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/commands/submit-and-wait")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2CommandsSubmitAndWaitForReassignmentRequest calls the generic PostV2CommandsSubmitAndWaitForReassignment builder with application/json body
func NewPostV2CommandsSubmitAndWaitForReassignmentRequest(server string, body PostV2CommandsSubmitAndWaitForReassignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2CommandsSubmitAndWaitForReassignmentRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2CommandsSubmitAndWaitForReassignmentRequestWithBody generates requests for PostV2CommandsSubmitAndWaitForReassignment with any type of body
func NewPostV2CommandsSubmitAndWaitForReassignmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/commands/submit-and-wait-for-reassignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2CommandsSubmitAndWaitForTransactionRequest calls the generic PostV2CommandsSubmitAndWaitForTransaction builder with application/json body
func NewPostV2CommandsSubmitAndWaitForTransactionRequest(server string, body PostV2CommandsSubmitAndWaitForTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2CommandsSubmitAndWaitForTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2CommandsSubmitAndWaitForTransactionRequestWithBody generates requests for PostV2CommandsSubmitAndWaitForTransaction with any type of body
func NewPostV2CommandsSubmitAndWaitForTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/commands/submit-and-wait-for-transaction")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2CommandsSubmitAndWaitForTransactionTreeRequest calls the generic PostV2CommandsSubmitAndWaitForTransactionTree builder with application/json body
func NewPostV2CommandsSubmitAndWaitForTransactionTreeRequest(server string, body PostV2CommandsSubmitAndWaitForTransactionTreeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2CommandsSubmitAndWaitForTransactionTreeRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2CommandsSubmitAndWaitForTransactionTreeRequestWithBody generates requests for PostV2CommandsSubmitAndWaitForTransactionTree with any type of body
func NewPostV2CommandsSubmitAndWaitForTransactionTreeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/commands/submit-and-wait-for-transaction-tree")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2EventsEventsByContractIdRequest calls the generic PostV2EventsEventsByContractId builder with application/json body
func NewPostV2EventsEventsByContractIdRequest(server string, body PostV2EventsEventsByContractIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2EventsEventsByContractIdRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2EventsEventsByContractIdRequestWithBody generates requests for PostV2EventsEventsByContractId with any type of body
func NewPostV2EventsEventsByContractIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/events/events-by-contract-id")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2IdpsRequest generates requests for GetV2Idps
func NewGetV2IdpsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2IdpsRequest calls the generic PostV2Idps builder with application/json body
func NewPostV2IdpsRequest(server string, body PostV2IdpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2IdpsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2IdpsRequestWithBody generates requests for PostV2Idps with any type of body
func NewPostV2IdpsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteV2IdpsIdpIdRequest generates requests for DeleteV2IdpsIdpId
func NewDeleteV2IdpsIdpIdRequest(server string, idpId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "idp-id", runtime.ParamLocationPath, idpId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/idps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2IdpsIdpIdRequest generates requests for GetV2IdpsIdpId
func NewGetV2IdpsIdpIdRequest(server string, idpId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "idp-id", runtime.ParamLocationPath, idpId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/idps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchV2IdpsIdpIdRequest calls the generic PatchV2IdpsIdpId builder with application/json body
func NewPatchV2IdpsIdpIdRequest(server string, idpId string, body PatchV2IdpsIdpIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2IdpsIdpIdRequestWithBody(server, idpId, "application/json", bodyReader)
}

// NewPatchV2IdpsIdpIdRequestWithBody generates requests for PatchV2IdpsIdpId with any type of body
func NewPatchV2IdpsIdpIdRequestWithBody(server string, idpId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "idp-id", runtime.ParamLocationPath, idpId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/idps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2InteractiveSubmissionExecuteRequest calls the generic PostV2InteractiveSubmissionExecute builder with application/json body
func NewPostV2InteractiveSubmissionExecuteRequest(server string, body PostV2InteractiveSubmissionExecuteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InteractiveSubmissionExecuteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2InteractiveSubmissionExecuteRequestWithBody generates requests for PostV2InteractiveSubmissionExecute with any type of body
func NewPostV2InteractiveSubmissionExecuteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/interactive-submission/execute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2InteractiveSubmissionPreferredPackageVersionRequest generates requests for GetV2InteractiveSubmissionPreferredPackageVersion
func NewGetV2InteractiveSubmissionPreferredPackageVersionRequest(server string, params *GetV2InteractiveSubmissionPreferredPackageVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/interactive-submission/preferred-package-version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Parties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parties", runtime.ParamLocationQuery, *params.Parties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "package-name", runtime.ParamLocationQuery, params.PackageName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.VettingValidAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vetting_valid_at", runtime.ParamLocationQuery, *params.VettingValidAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SynchronizerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "synchronizer-id", runtime.ParamLocationQuery, *params.SynchronizerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2InteractiveSubmissionPrepareRequest calls the generic PostV2InteractiveSubmissionPrepare builder with application/json body
func NewPostV2InteractiveSubmissionPrepareRequest(server string, body PostV2InteractiveSubmissionPrepareJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2InteractiveSubmissionPrepareRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2InteractiveSubmissionPrepareRequestWithBody generates requests for PostV2InteractiveSubmissionPrepare with any type of body
func NewPostV2InteractiveSubmissionPrepareRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/interactive-submission/prepare")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2PackagesRequest generates requests for GetV2Packages
func NewGetV2PackagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2PackagesRequestWithBody generates requests for PostV2Packages with any type of body
func NewPostV2PackagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2PackagesPackageIdRequest generates requests for GetV2PackagesPackageId
func NewGetV2PackagesPackageIdRequest(server string, packageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package-id", runtime.ParamLocationPath, packageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/packages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2PackagesPackageIdStatusRequest generates requests for GetV2PackagesPackageIdStatus
func NewGetV2PackagesPackageIdStatusRequest(server string, packageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package-id", runtime.ParamLocationPath, packageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/packages/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2PartiesRequest generates requests for GetV2Parties
func NewGetV2PartiesRequest(server string, params *GetV2PartiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/parties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2PartiesRequest calls the generic PostV2Parties builder with application/json body
func NewPostV2PartiesRequest(server string, body PostV2PartiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2PartiesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2PartiesRequestWithBody generates requests for PostV2Parties with any type of body
func NewPostV2PartiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/parties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2PartiesParticipantIdRequest generates requests for GetV2PartiesParticipantId
func NewGetV2PartiesParticipantIdRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/parties/participant-id")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2PartiesPartyRequest generates requests for GetV2PartiesParty
func NewGetV2PartiesPartyRequest(server string, party string, params *GetV2PartiesPartyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "party", runtime.ParamLocationPath, party)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/parties/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IdentityProviderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identity-provider-id", runtime.ParamLocationQuery, *params.IdentityProviderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parties", runtime.ParamLocationQuery, *params.Parties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchV2PartiesPartyRequest calls the generic PatchV2PartiesParty builder with application/json body
func NewPatchV2PartiesPartyRequest(server string, party string, body PatchV2PartiesPartyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2PartiesPartyRequestWithBody(server, party, "application/json", bodyReader)
}

// NewPatchV2PartiesPartyRequestWithBody generates requests for PatchV2PartiesParty with any type of body
func NewPatchV2PartiesPartyRequestWithBody(server string, party string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "party", runtime.ParamLocationPath, party)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/parties/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2StateActiveContractsRequest calls the generic PostV2StateActiveContracts builder with application/json body
func NewPostV2StateActiveContractsRequest(server string, params *PostV2StateActiveContractsParams, body PostV2StateActiveContractsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2StateActiveContractsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV2StateActiveContractsRequestWithBody generates requests for PostV2StateActiveContracts with any type of body
func NewPostV2StateActiveContractsRequestWithBody(server string, params *PostV2StateActiveContractsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/state/active-contracts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamIdleTimeoutMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream_idle_timeout_ms", runtime.ParamLocationQuery, *params.StreamIdleTimeoutMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2StateConnectedSynchronizersRequest generates requests for GetV2StateConnectedSynchronizers
func NewGetV2StateConnectedSynchronizersRequest(server string, params *GetV2StateConnectedSynchronizersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/state/connected-synchronizers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "party", runtime.ParamLocationQuery, params.Party); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ParticipantId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "participantId", runtime.ParamLocationQuery, *params.ParticipantId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2StateLatestPrunedOffsetsRequest generates requests for GetV2StateLatestPrunedOffsets
func NewGetV2StateLatestPrunedOffsetsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/state/latest-pruned-offsets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2StateLedgerEndRequest generates requests for GetV2StateLedgerEnd
func NewGetV2StateLedgerEndRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/state/ledger-end")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2UpdatesFlatsRequest calls the generic PostV2UpdatesFlats builder with application/json body
func NewPostV2UpdatesFlatsRequest(server string, params *PostV2UpdatesFlatsParams, body PostV2UpdatesFlatsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UpdatesFlatsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV2UpdatesFlatsRequestWithBody generates requests for PostV2UpdatesFlats with any type of body
func NewPostV2UpdatesFlatsRequestWithBody(server string, params *PostV2UpdatesFlatsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/flats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamIdleTimeoutMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream_idle_timeout_ms", runtime.ParamLocationQuery, *params.StreamIdleTimeoutMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2UpdatesTransactionByIdRequest calls the generic PostV2UpdatesTransactionById builder with application/json body
func NewPostV2UpdatesTransactionByIdRequest(server string, body PostV2UpdatesTransactionByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UpdatesTransactionByIdRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2UpdatesTransactionByIdRequestWithBody generates requests for PostV2UpdatesTransactionById with any type of body
func NewPostV2UpdatesTransactionByIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/transaction-by-id")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2UpdatesTransactionByOffsetRequest calls the generic PostV2UpdatesTransactionByOffset builder with application/json body
func NewPostV2UpdatesTransactionByOffsetRequest(server string, body PostV2UpdatesTransactionByOffsetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UpdatesTransactionByOffsetRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2UpdatesTransactionByOffsetRequestWithBody generates requests for PostV2UpdatesTransactionByOffset with any type of body
func NewPostV2UpdatesTransactionByOffsetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/transaction-by-offset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2UpdatesTransactionTreeByIdUpdateIdRequest generates requests for GetV2UpdatesTransactionTreeByIdUpdateId
func NewGetV2UpdatesTransactionTreeByIdUpdateIdRequest(server string, updateId string, params *GetV2UpdatesTransactionTreeByIdUpdateIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "update-id", runtime.ParamLocationPath, updateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/transaction-tree-by-id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Parties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parties", runtime.ParamLocationQuery, *params.Parties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2UpdatesTransactionTreeByOffsetOffsetRequest generates requests for GetV2UpdatesTransactionTreeByOffsetOffset
func NewGetV2UpdatesTransactionTreeByOffsetOffsetRequest(server string, offset int64, params *GetV2UpdatesTransactionTreeByOffsetOffsetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "offset", runtime.ParamLocationPath, offset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/transaction-tree-by-offset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Parties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parties", runtime.ParamLocationQuery, *params.Parties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2UpdatesTreesRequest calls the generic PostV2UpdatesTrees builder with application/json body
func NewPostV2UpdatesTreesRequest(server string, params *PostV2UpdatesTreesParams, body PostV2UpdatesTreesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UpdatesTreesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV2UpdatesTreesRequestWithBody generates requests for PostV2UpdatesTrees with any type of body
func NewPostV2UpdatesTreesRequestWithBody(server string, params *PostV2UpdatesTreesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/trees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamIdleTimeoutMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream_idle_timeout_ms", runtime.ParamLocationQuery, *params.StreamIdleTimeoutMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2UpdatesUpdateByIdRequest calls the generic PostV2UpdatesUpdateById builder with application/json body
func NewPostV2UpdatesUpdateByIdRequest(server string, body PostV2UpdatesUpdateByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UpdatesUpdateByIdRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2UpdatesUpdateByIdRequestWithBody generates requests for PostV2UpdatesUpdateById with any type of body
func NewPostV2UpdatesUpdateByIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/update-by-id")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2UpdatesUpdateByOffsetRequest calls the generic PostV2UpdatesUpdateByOffset builder with application/json body
func NewPostV2UpdatesUpdateByOffsetRequest(server string, body PostV2UpdatesUpdateByOffsetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UpdatesUpdateByOffsetRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2UpdatesUpdateByOffsetRequestWithBody generates requests for PostV2UpdatesUpdateByOffset with any type of body
func NewPostV2UpdatesUpdateByOffsetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/updates/update-by-offset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2UsersRequest generates requests for GetV2Users
func NewGetV2UsersRequest(server string, params *GetV2UsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV2UsersRequest calls the generic PostV2Users builder with application/json body
func NewPostV2UsersRequest(server string, body PostV2UsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UsersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV2UsersRequestWithBody generates requests for PostV2Users with any type of body
func NewPostV2UsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteV2UsersUserIdRequest generates requests for DeleteV2UsersUserId
func NewDeleteV2UsersUserIdRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV2UsersUserIdRequest generates requests for GetV2UsersUserId
func NewGetV2UsersUserIdRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchV2UsersUserIdRequest calls the generic PatchV2UsersUserId builder with application/json body
func NewPatchV2UsersUserIdRequest(server string, userId string, body PatchV2UsersUserIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2UsersUserIdRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPatchV2UsersUserIdRequestWithBody generates requests for PatchV2UsersUserId with any type of body
func NewPatchV2UsersUserIdRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchV2UsersUserIdIdentityProviderIdRequest calls the generic PatchV2UsersUserIdIdentityProviderId builder with application/json body
func NewPatchV2UsersUserIdIdentityProviderIdRequest(server string, userId string, body PatchV2UsersUserIdIdentityProviderIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2UsersUserIdIdentityProviderIdRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPatchV2UsersUserIdIdentityProviderIdRequestWithBody generates requests for PatchV2UsersUserIdIdentityProviderId with any type of body
func NewPatchV2UsersUserIdIdentityProviderIdRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s/identity-provider-id", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2UsersUserIdRightsRequest generates requests for GetV2UsersUserIdRights
func NewGetV2UsersUserIdRightsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s/rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchV2UsersUserIdRightsRequest calls the generic PatchV2UsersUserIdRights builder with application/json body
func NewPatchV2UsersUserIdRightsRequest(server string, userId string, body PatchV2UsersUserIdRightsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchV2UsersUserIdRightsRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPatchV2UsersUserIdRightsRequestWithBody generates requests for PatchV2UsersUserIdRights with any type of body
func NewPatchV2UsersUserIdRightsRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s/rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV2UsersUserIdRightsRequest calls the generic PostV2UsersUserIdRights builder with application/json body
func NewPostV2UsersUserIdRightsRequest(server string, userId string, body PostV2UsersUserIdRightsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV2UsersUserIdRightsRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPostV2UsersUserIdRightsRequestWithBody generates requests for PostV2UsersUserIdRights with any type of body
func NewPostV2UsersUserIdRightsRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/users/%s/rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2VersionRequest generates requests for GetV2Version
func NewGetV2VersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostV2CommandsAsyncSubmitWithBodyWithResponse request with any body
	PostV2CommandsAsyncSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitResponse, error)

	PostV2CommandsAsyncSubmitWithResponse(ctx context.Context, body PostV2CommandsAsyncSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitResponse, error)

	// PostV2CommandsAsyncSubmitReassignmentWithBodyWithResponse request with any body
	PostV2CommandsAsyncSubmitReassignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitReassignmentResponse, error)

	PostV2CommandsAsyncSubmitReassignmentWithResponse(ctx context.Context, body PostV2CommandsAsyncSubmitReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitReassignmentResponse, error)

	// PostV2CommandsCompletionsWithBodyWithResponse request with any body
	PostV2CommandsCompletionsWithBodyWithResponse(ctx context.Context, params *PostV2CommandsCompletionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsCompletionsResponse, error)

	PostV2CommandsCompletionsWithResponse(ctx context.Context, params *PostV2CommandsCompletionsParams, body PostV2CommandsCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsCompletionsResponse, error)

	// PostV2CommandsSubmitAndWaitWithBodyWithResponse request with any body
	PostV2CommandsSubmitAndWaitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitResponse, error)

	PostV2CommandsSubmitAndWaitWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitResponse, error)

	// PostV2CommandsSubmitAndWaitForReassignmentWithBodyWithResponse request with any body
	PostV2CommandsSubmitAndWaitForReassignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForReassignmentResponse, error)

	PostV2CommandsSubmitAndWaitForReassignmentWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitForReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForReassignmentResponse, error)

	// PostV2CommandsSubmitAndWaitForTransactionWithBodyWithResponse request with any body
	PostV2CommandsSubmitAndWaitForTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionResponse, error)

	PostV2CommandsSubmitAndWaitForTransactionWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionResponse, error)

	// PostV2CommandsSubmitAndWaitForTransactionTreeWithBodyWithResponse request with any body
	PostV2CommandsSubmitAndWaitForTransactionTreeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionTreeResponse, error)

	PostV2CommandsSubmitAndWaitForTransactionTreeWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionTreeResponse, error)

	// PostV2EventsEventsByContractIdWithBodyWithResponse request with any body
	PostV2EventsEventsByContractIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2EventsEventsByContractIdResponse, error)

	PostV2EventsEventsByContractIdWithResponse(ctx context.Context, body PostV2EventsEventsByContractIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2EventsEventsByContractIdResponse, error)

	// GetV2IdpsWithResponse request
	GetV2IdpsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2IdpsResponse, error)

	// PostV2IdpsWithBodyWithResponse request with any body
	PostV2IdpsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2IdpsResponse, error)

	PostV2IdpsWithResponse(ctx context.Context, body PostV2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2IdpsResponse, error)

	// DeleteV2IdpsIdpIdWithResponse request
	DeleteV2IdpsIdpIdWithResponse(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*DeleteV2IdpsIdpIdResponse, error)

	// GetV2IdpsIdpIdWithResponse request
	GetV2IdpsIdpIdWithResponse(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*GetV2IdpsIdpIdResponse, error)

	// PatchV2IdpsIdpIdWithBodyWithResponse request with any body
	PatchV2IdpsIdpIdWithBodyWithResponse(ctx context.Context, idpId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2IdpsIdpIdResponse, error)

	PatchV2IdpsIdpIdWithResponse(ctx context.Context, idpId string, body PatchV2IdpsIdpIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2IdpsIdpIdResponse, error)

	// PostV2InteractiveSubmissionExecuteWithBodyWithResponse request with any body
	PostV2InteractiveSubmissionExecuteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionExecuteResponse, error)

	PostV2InteractiveSubmissionExecuteWithResponse(ctx context.Context, body PostV2InteractiveSubmissionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionExecuteResponse, error)

	// GetV2InteractiveSubmissionPreferredPackageVersionWithResponse request
	GetV2InteractiveSubmissionPreferredPackageVersionWithResponse(ctx context.Context, params *GetV2InteractiveSubmissionPreferredPackageVersionParams, reqEditors ...RequestEditorFn) (*GetV2InteractiveSubmissionPreferredPackageVersionResponse, error)

	// PostV2InteractiveSubmissionPrepareWithBodyWithResponse request with any body
	PostV2InteractiveSubmissionPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionPrepareResponse, error)

	PostV2InteractiveSubmissionPrepareWithResponse(ctx context.Context, body PostV2InteractiveSubmissionPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionPrepareResponse, error)

	// GetV2PackagesWithResponse request
	GetV2PackagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2PackagesResponse, error)

	// PostV2PackagesWithBodyWithResponse request with any body
	PostV2PackagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2PackagesResponse, error)

	// GetV2PackagesPackageIdWithResponse request
	GetV2PackagesPackageIdWithResponse(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*GetV2PackagesPackageIdResponse, error)

	// GetV2PackagesPackageIdStatusWithResponse request
	GetV2PackagesPackageIdStatusWithResponse(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*GetV2PackagesPackageIdStatusResponse, error)

	// GetV2PartiesWithResponse request
	GetV2PartiesWithResponse(ctx context.Context, params *GetV2PartiesParams, reqEditors ...RequestEditorFn) (*GetV2PartiesResponse, error)

	// PostV2PartiesWithBodyWithResponse request with any body
	PostV2PartiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2PartiesResponse, error)

	PostV2PartiesWithResponse(ctx context.Context, body PostV2PartiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PartiesResponse, error)

	// GetV2PartiesParticipantIdWithResponse request
	GetV2PartiesParticipantIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2PartiesParticipantIdResponse, error)

	// GetV2PartiesPartyWithResponse request
	GetV2PartiesPartyWithResponse(ctx context.Context, party string, params *GetV2PartiesPartyParams, reqEditors ...RequestEditorFn) (*GetV2PartiesPartyResponse, error)

	// PatchV2PartiesPartyWithBodyWithResponse request with any body
	PatchV2PartiesPartyWithBodyWithResponse(ctx context.Context, party string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2PartiesPartyResponse, error)

	PatchV2PartiesPartyWithResponse(ctx context.Context, party string, body PatchV2PartiesPartyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2PartiesPartyResponse, error)

	// PostV2StateActiveContractsWithBodyWithResponse request with any body
	PostV2StateActiveContractsWithBodyWithResponse(ctx context.Context, params *PostV2StateActiveContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2StateActiveContractsResponse, error)

	PostV2StateActiveContractsWithResponse(ctx context.Context, params *PostV2StateActiveContractsParams, body PostV2StateActiveContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2StateActiveContractsResponse, error)

	// GetV2StateConnectedSynchronizersWithResponse request
	GetV2StateConnectedSynchronizersWithResponse(ctx context.Context, params *GetV2StateConnectedSynchronizersParams, reqEditors ...RequestEditorFn) (*GetV2StateConnectedSynchronizersResponse, error)

	// GetV2StateLatestPrunedOffsetsWithResponse request
	GetV2StateLatestPrunedOffsetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2StateLatestPrunedOffsetsResponse, error)

	// GetV2StateLedgerEndWithResponse request
	GetV2StateLedgerEndWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2StateLedgerEndResponse, error)

	// PostV2UpdatesFlatsWithBodyWithResponse request with any body
	PostV2UpdatesFlatsWithBodyWithResponse(ctx context.Context, params *PostV2UpdatesFlatsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesFlatsResponse, error)

	PostV2UpdatesFlatsWithResponse(ctx context.Context, params *PostV2UpdatesFlatsParams, body PostV2UpdatesFlatsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesFlatsResponse, error)

	// PostV2UpdatesTransactionByIdWithBodyWithResponse request with any body
	PostV2UpdatesTransactionByIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByIdResponse, error)

	PostV2UpdatesTransactionByIdWithResponse(ctx context.Context, body PostV2UpdatesTransactionByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByIdResponse, error)

	// PostV2UpdatesTransactionByOffsetWithBodyWithResponse request with any body
	PostV2UpdatesTransactionByOffsetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByOffsetResponse, error)

	PostV2UpdatesTransactionByOffsetWithResponse(ctx context.Context, body PostV2UpdatesTransactionByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByOffsetResponse, error)

	// GetV2UpdatesTransactionTreeByIdUpdateIdWithResponse request
	GetV2UpdatesTransactionTreeByIdUpdateIdWithResponse(ctx context.Context, updateId string, params *GetV2UpdatesTransactionTreeByIdUpdateIdParams, reqEditors ...RequestEditorFn) (*GetV2UpdatesTransactionTreeByIdUpdateIdResponse, error)

	// GetV2UpdatesTransactionTreeByOffsetOffsetWithResponse request
	GetV2UpdatesTransactionTreeByOffsetOffsetWithResponse(ctx context.Context, offset int64, params *GetV2UpdatesTransactionTreeByOffsetOffsetParams, reqEditors ...RequestEditorFn) (*GetV2UpdatesTransactionTreeByOffsetOffsetResponse, error)

	// PostV2UpdatesTreesWithBodyWithResponse request with any body
	PostV2UpdatesTreesWithBodyWithResponse(ctx context.Context, params *PostV2UpdatesTreesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesTreesResponse, error)

	PostV2UpdatesTreesWithResponse(ctx context.Context, params *PostV2UpdatesTreesParams, body PostV2UpdatesTreesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesTreesResponse, error)

	// PostV2UpdatesUpdateByIdWithBodyWithResponse request with any body
	PostV2UpdatesUpdateByIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByIdResponse, error)

	PostV2UpdatesUpdateByIdWithResponse(ctx context.Context, body PostV2UpdatesUpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByIdResponse, error)

	// PostV2UpdatesUpdateByOffsetWithBodyWithResponse request with any body
	PostV2UpdatesUpdateByOffsetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByOffsetResponse, error)

	PostV2UpdatesUpdateByOffsetWithResponse(ctx context.Context, body PostV2UpdatesUpdateByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByOffsetResponse, error)

	// GetV2UsersWithResponse request
	GetV2UsersWithResponse(ctx context.Context, params *GetV2UsersParams, reqEditors ...RequestEditorFn) (*GetV2UsersResponse, error)

	// PostV2UsersWithBodyWithResponse request with any body
	PostV2UsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UsersResponse, error)

	PostV2UsersWithResponse(ctx context.Context, body PostV2UsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UsersResponse, error)

	// DeleteV2UsersUserIdWithResponse request
	DeleteV2UsersUserIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteV2UsersUserIdResponse, error)

	// GetV2UsersUserIdWithResponse request
	GetV2UsersUserIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetV2UsersUserIdResponse, error)

	// PatchV2UsersUserIdWithBodyWithResponse request with any body
	PatchV2UsersUserIdWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdResponse, error)

	PatchV2UsersUserIdWithResponse(ctx context.Context, userId string, body PatchV2UsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdResponse, error)

	// PatchV2UsersUserIdIdentityProviderIdWithBodyWithResponse request with any body
	PatchV2UsersUserIdIdentityProviderIdWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdIdentityProviderIdResponse, error)

	PatchV2UsersUserIdIdentityProviderIdWithResponse(ctx context.Context, userId string, body PatchV2UsersUserIdIdentityProviderIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdIdentityProviderIdResponse, error)

	// GetV2UsersUserIdRightsWithResponse request
	GetV2UsersUserIdRightsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetV2UsersUserIdRightsResponse, error)

	// PatchV2UsersUserIdRightsWithBodyWithResponse request with any body
	PatchV2UsersUserIdRightsWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdRightsResponse, error)

	PatchV2UsersUserIdRightsWithResponse(ctx context.Context, userId string, body PatchV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdRightsResponse, error)

	// PostV2UsersUserIdRightsWithBodyWithResponse request with any body
	PostV2UsersUserIdRightsWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UsersUserIdRightsResponse, error)

	PostV2UsersUserIdRightsWithResponse(ctx context.Context, userId string, body PostV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UsersUserIdRightsResponse, error)

	// GetV2VersionWithResponse request
	GetV2VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2VersionResponse, error)
}

type PostV2CommandsAsyncSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubmitResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2CommandsAsyncSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2CommandsAsyncSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2CommandsAsyncSubmitReassignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubmitReassignmentResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2CommandsAsyncSubmitReassignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2CommandsAsyncSubmitReassignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2CommandsCompletionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CompletionStreamResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2CommandsCompletionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2CommandsCompletionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2CommandsSubmitAndWaitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubmitAndWaitResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2CommandsSubmitAndWaitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2CommandsSubmitAndWaitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2CommandsSubmitAndWaitForReassignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsSubmitAndWaitForReassignmentResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2CommandsSubmitAndWaitForReassignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2CommandsSubmitAndWaitForReassignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2CommandsSubmitAndWaitForTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsSubmitAndWaitForTransactionResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2CommandsSubmitAndWaitForTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2CommandsSubmitAndWaitForTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2CommandsSubmitAndWaitForTransactionTreeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsSubmitAndWaitForTransactionTreeResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2CommandsSubmitAndWaitForTransactionTreeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2CommandsSubmitAndWaitForTransactionTreeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2EventsEventsByContractIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsGetEventsByContractIdResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2EventsEventsByContractIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2EventsEventsByContractIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2IdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIdentityProviderConfigsResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2IdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2IdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2IdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateIdentityProviderConfigResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2IdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2IdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteV2IdpsIdpIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteIdentityProviderConfigResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r DeleteV2IdpsIdpIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteV2IdpsIdpIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2IdpsIdpIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetIdentityProviderConfigResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2IdpsIdpIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2IdpsIdpIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2IdpsIdpIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateIdentityProviderConfigResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PatchV2IdpsIdpIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2IdpsIdpIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2InteractiveSubmissionExecuteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExecuteSubmissionResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2InteractiveSubmissionExecuteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2InteractiveSubmissionExecuteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2InteractiveSubmissionPreferredPackageVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPreferredPackageVersionResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2InteractiveSubmissionPreferredPackageVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2InteractiveSubmissionPreferredPackageVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2InteractiveSubmissionPrepareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsPrepareSubmissionResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2InteractiveSubmissionPrepareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2InteractiveSubmissionPrepareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2PackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPackagesResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2PackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2PackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2PackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadDarFileResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2PackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2PackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2PackagesPackageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2PackagesPackageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2PackagesPackageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2PackagesPackageIdStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPackageStatusResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2PackagesPackageIdStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2PackagesPackageIdStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2PartiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListKnownPartiesResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2PartiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2PartiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2PartiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllocatePartyResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2PartiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2PartiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2PartiesParticipantIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetParticipantIdResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2PartiesParticipantIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2PartiesParticipantIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2PartiesPartyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPartiesResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2PartiesPartyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2PartiesPartyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2PartiesPartyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePartyDetailsResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PatchV2PartiesPartyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2PartiesPartyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2StateActiveContractsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JsGetActiveContractsResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2StateActiveContractsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2StateActiveContractsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2StateConnectedSynchronizersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConnectedSynchronizersResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2StateConnectedSynchronizersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2StateConnectedSynchronizersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2StateLatestPrunedOffsetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLatestPrunedOffsetsResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2StateLatestPrunedOffsetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2StateLatestPrunedOffsetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2StateLedgerEndResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLedgerEndResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2StateLedgerEndResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2StateLedgerEndResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UpdatesFlatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JsGetUpdatesResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UpdatesFlatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UpdatesFlatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UpdatesTransactionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsGetTransactionResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UpdatesTransactionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UpdatesTransactionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UpdatesTransactionByOffsetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsGetTransactionResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UpdatesTransactionByOffsetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UpdatesTransactionByOffsetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2UpdatesTransactionTreeByIdUpdateIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsGetTransactionTreeResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2UpdatesTransactionTreeByIdUpdateIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2UpdatesTransactionTreeByIdUpdateIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2UpdatesTransactionTreeByOffsetOffsetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsGetTransactionTreeResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2UpdatesTransactionTreeByOffsetOffsetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2UpdatesTransactionTreeByOffsetOffsetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UpdatesTreesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JsGetUpdateTreesResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UpdatesTreesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UpdatesTreesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UpdatesUpdateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsGetUpdateResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UpdatesUpdateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UpdatesUpdateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UpdatesUpdateByOffsetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsGetUpdateResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UpdatesUpdateByOffsetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UpdatesUpdateByOffsetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2UsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsersResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2UsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2UsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateUserResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteV2UsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r DeleteV2UsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteV2UsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2UsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2UsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2UsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2UsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PatchV2UsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2UsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2UsersUserIdIdentityProviderIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserIdentityProviderIdResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PatchV2UsersUserIdIdentityProviderIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2UsersUserIdIdentityProviderIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2UsersUserIdRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUserRightsResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2UsersUserIdRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2UsersUserIdRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchV2UsersUserIdRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevokeUserRightsResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PatchV2UsersUserIdRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchV2UsersUserIdRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV2UsersUserIdRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GrantUserRightsResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r PostV2UsersUserIdRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV2UsersUserIdRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2VersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLedgerApiVersionResponse
	JSONDefault  *JsCantonError
}

// Status returns HTTPResponse.Status
func (r GetV2VersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2VersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostV2CommandsAsyncSubmitWithBodyWithResponse request with arbitrary body returning *PostV2CommandsAsyncSubmitResponse
func (c *ClientWithResponses) PostV2CommandsAsyncSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitResponse, error) {
	rsp, err := c.PostV2CommandsAsyncSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsAsyncSubmitResponse(rsp)
}

func (c *ClientWithResponses) PostV2CommandsAsyncSubmitWithResponse(ctx context.Context, body PostV2CommandsAsyncSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitResponse, error) {
	rsp, err := c.PostV2CommandsAsyncSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsAsyncSubmitResponse(rsp)
}

// PostV2CommandsAsyncSubmitReassignmentWithBodyWithResponse request with arbitrary body returning *PostV2CommandsAsyncSubmitReassignmentResponse
func (c *ClientWithResponses) PostV2CommandsAsyncSubmitReassignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitReassignmentResponse, error) {
	rsp, err := c.PostV2CommandsAsyncSubmitReassignmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsAsyncSubmitReassignmentResponse(rsp)
}

func (c *ClientWithResponses) PostV2CommandsAsyncSubmitReassignmentWithResponse(ctx context.Context, body PostV2CommandsAsyncSubmitReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsAsyncSubmitReassignmentResponse, error) {
	rsp, err := c.PostV2CommandsAsyncSubmitReassignment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsAsyncSubmitReassignmentResponse(rsp)
}

// PostV2CommandsCompletionsWithBodyWithResponse request with arbitrary body returning *PostV2CommandsCompletionsResponse
func (c *ClientWithResponses) PostV2CommandsCompletionsWithBodyWithResponse(ctx context.Context, params *PostV2CommandsCompletionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsCompletionsResponse, error) {
	rsp, err := c.PostV2CommandsCompletionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsCompletionsResponse(rsp)
}

func (c *ClientWithResponses) PostV2CommandsCompletionsWithResponse(ctx context.Context, params *PostV2CommandsCompletionsParams, body PostV2CommandsCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsCompletionsResponse, error) {
	rsp, err := c.PostV2CommandsCompletions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsCompletionsResponse(rsp)
}

// PostV2CommandsSubmitAndWaitWithBodyWithResponse request with arbitrary body returning *PostV2CommandsSubmitAndWaitResponse
func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWaitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitResponse(rsp)
}

func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWait(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitResponse(rsp)
}

// PostV2CommandsSubmitAndWaitForReassignmentWithBodyWithResponse request with arbitrary body returning *PostV2CommandsSubmitAndWaitForReassignmentResponse
func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitForReassignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForReassignmentResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWaitForReassignmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitForReassignmentResponse(rsp)
}

func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitForReassignmentWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitForReassignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForReassignmentResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWaitForReassignment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitForReassignmentResponse(rsp)
}

// PostV2CommandsSubmitAndWaitForTransactionWithBodyWithResponse request with arbitrary body returning *PostV2CommandsSubmitAndWaitForTransactionResponse
func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitForTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWaitForTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitForTransactionResponse(rsp)
}

func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitForTransactionWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWaitForTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitForTransactionResponse(rsp)
}

// PostV2CommandsSubmitAndWaitForTransactionTreeWithBodyWithResponse request with arbitrary body returning *PostV2CommandsSubmitAndWaitForTransactionTreeResponse
func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitForTransactionTreeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionTreeResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWaitForTransactionTreeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitForTransactionTreeResponse(rsp)
}

func (c *ClientWithResponses) PostV2CommandsSubmitAndWaitForTransactionTreeWithResponse(ctx context.Context, body PostV2CommandsSubmitAndWaitForTransactionTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2CommandsSubmitAndWaitForTransactionTreeResponse, error) {
	rsp, err := c.PostV2CommandsSubmitAndWaitForTransactionTree(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2CommandsSubmitAndWaitForTransactionTreeResponse(rsp)
}

// PostV2EventsEventsByContractIdWithBodyWithResponse request with arbitrary body returning *PostV2EventsEventsByContractIdResponse
func (c *ClientWithResponses) PostV2EventsEventsByContractIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2EventsEventsByContractIdResponse, error) {
	rsp, err := c.PostV2EventsEventsByContractIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2EventsEventsByContractIdResponse(rsp)
}

func (c *ClientWithResponses) PostV2EventsEventsByContractIdWithResponse(ctx context.Context, body PostV2EventsEventsByContractIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2EventsEventsByContractIdResponse, error) {
	rsp, err := c.PostV2EventsEventsByContractId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2EventsEventsByContractIdResponse(rsp)
}

// GetV2IdpsWithResponse request returning *GetV2IdpsResponse
func (c *ClientWithResponses) GetV2IdpsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2IdpsResponse, error) {
	rsp, err := c.GetV2Idps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2IdpsResponse(rsp)
}

// PostV2IdpsWithBodyWithResponse request with arbitrary body returning *PostV2IdpsResponse
func (c *ClientWithResponses) PostV2IdpsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2IdpsResponse, error) {
	rsp, err := c.PostV2IdpsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2IdpsResponse(rsp)
}

func (c *ClientWithResponses) PostV2IdpsWithResponse(ctx context.Context, body PostV2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2IdpsResponse, error) {
	rsp, err := c.PostV2Idps(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2IdpsResponse(rsp)
}

// DeleteV2IdpsIdpIdWithResponse request returning *DeleteV2IdpsIdpIdResponse
func (c *ClientWithResponses) DeleteV2IdpsIdpIdWithResponse(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*DeleteV2IdpsIdpIdResponse, error) {
	rsp, err := c.DeleteV2IdpsIdpId(ctx, idpId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2IdpsIdpIdResponse(rsp)
}

// GetV2IdpsIdpIdWithResponse request returning *GetV2IdpsIdpIdResponse
func (c *ClientWithResponses) GetV2IdpsIdpIdWithResponse(ctx context.Context, idpId string, reqEditors ...RequestEditorFn) (*GetV2IdpsIdpIdResponse, error) {
	rsp, err := c.GetV2IdpsIdpId(ctx, idpId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2IdpsIdpIdResponse(rsp)
}

// PatchV2IdpsIdpIdWithBodyWithResponse request with arbitrary body returning *PatchV2IdpsIdpIdResponse
func (c *ClientWithResponses) PatchV2IdpsIdpIdWithBodyWithResponse(ctx context.Context, idpId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2IdpsIdpIdResponse, error) {
	rsp, err := c.PatchV2IdpsIdpIdWithBody(ctx, idpId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2IdpsIdpIdResponse(rsp)
}

func (c *ClientWithResponses) PatchV2IdpsIdpIdWithResponse(ctx context.Context, idpId string, body PatchV2IdpsIdpIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2IdpsIdpIdResponse, error) {
	rsp, err := c.PatchV2IdpsIdpId(ctx, idpId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2IdpsIdpIdResponse(rsp)
}

// PostV2InteractiveSubmissionExecuteWithBodyWithResponse request with arbitrary body returning *PostV2InteractiveSubmissionExecuteResponse
func (c *ClientWithResponses) PostV2InteractiveSubmissionExecuteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionExecuteResponse, error) {
	rsp, err := c.PostV2InteractiveSubmissionExecuteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InteractiveSubmissionExecuteResponse(rsp)
}

func (c *ClientWithResponses) PostV2InteractiveSubmissionExecuteWithResponse(ctx context.Context, body PostV2InteractiveSubmissionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionExecuteResponse, error) {
	rsp, err := c.PostV2InteractiveSubmissionExecute(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InteractiveSubmissionExecuteResponse(rsp)
}

// GetV2InteractiveSubmissionPreferredPackageVersionWithResponse request returning *GetV2InteractiveSubmissionPreferredPackageVersionResponse
func (c *ClientWithResponses) GetV2InteractiveSubmissionPreferredPackageVersionWithResponse(ctx context.Context, params *GetV2InteractiveSubmissionPreferredPackageVersionParams, reqEditors ...RequestEditorFn) (*GetV2InteractiveSubmissionPreferredPackageVersionResponse, error) {
	rsp, err := c.GetV2InteractiveSubmissionPreferredPackageVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2InteractiveSubmissionPreferredPackageVersionResponse(rsp)
}

// PostV2InteractiveSubmissionPrepareWithBodyWithResponse request with arbitrary body returning *PostV2InteractiveSubmissionPrepareResponse
func (c *ClientWithResponses) PostV2InteractiveSubmissionPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionPrepareResponse, error) {
	rsp, err := c.PostV2InteractiveSubmissionPrepareWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InteractiveSubmissionPrepareResponse(rsp)
}

func (c *ClientWithResponses) PostV2InteractiveSubmissionPrepareWithResponse(ctx context.Context, body PostV2InteractiveSubmissionPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2InteractiveSubmissionPrepareResponse, error) {
	rsp, err := c.PostV2InteractiveSubmissionPrepare(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2InteractiveSubmissionPrepareResponse(rsp)
}

// GetV2PackagesWithResponse request returning *GetV2PackagesResponse
func (c *ClientWithResponses) GetV2PackagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2PackagesResponse, error) {
	rsp, err := c.GetV2Packages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2PackagesResponse(rsp)
}

// PostV2PackagesWithBodyWithResponse request with arbitrary body returning *PostV2PackagesResponse
func (c *ClientWithResponses) PostV2PackagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2PackagesResponse, error) {
	rsp, err := c.PostV2PackagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2PackagesResponse(rsp)
}

// GetV2PackagesPackageIdWithResponse request returning *GetV2PackagesPackageIdResponse
func (c *ClientWithResponses) GetV2PackagesPackageIdWithResponse(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*GetV2PackagesPackageIdResponse, error) {
	rsp, err := c.GetV2PackagesPackageId(ctx, packageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2PackagesPackageIdResponse(rsp)
}

// GetV2PackagesPackageIdStatusWithResponse request returning *GetV2PackagesPackageIdStatusResponse
func (c *ClientWithResponses) GetV2PackagesPackageIdStatusWithResponse(ctx context.Context, packageId string, reqEditors ...RequestEditorFn) (*GetV2PackagesPackageIdStatusResponse, error) {
	rsp, err := c.GetV2PackagesPackageIdStatus(ctx, packageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2PackagesPackageIdStatusResponse(rsp)
}

// GetV2PartiesWithResponse request returning *GetV2PartiesResponse
func (c *ClientWithResponses) GetV2PartiesWithResponse(ctx context.Context, params *GetV2PartiesParams, reqEditors ...RequestEditorFn) (*GetV2PartiesResponse, error) {
	rsp, err := c.GetV2Parties(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2PartiesResponse(rsp)
}

// PostV2PartiesWithBodyWithResponse request with arbitrary body returning *PostV2PartiesResponse
func (c *ClientWithResponses) PostV2PartiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2PartiesResponse, error) {
	rsp, err := c.PostV2PartiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2PartiesResponse(rsp)
}

func (c *ClientWithResponses) PostV2PartiesWithResponse(ctx context.Context, body PostV2PartiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2PartiesResponse, error) {
	rsp, err := c.PostV2Parties(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2PartiesResponse(rsp)
}

// GetV2PartiesParticipantIdWithResponse request returning *GetV2PartiesParticipantIdResponse
func (c *ClientWithResponses) GetV2PartiesParticipantIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2PartiesParticipantIdResponse, error) {
	rsp, err := c.GetV2PartiesParticipantId(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2PartiesParticipantIdResponse(rsp)
}

// GetV2PartiesPartyWithResponse request returning *GetV2PartiesPartyResponse
func (c *ClientWithResponses) GetV2PartiesPartyWithResponse(ctx context.Context, party string, params *GetV2PartiesPartyParams, reqEditors ...RequestEditorFn) (*GetV2PartiesPartyResponse, error) {
	rsp, err := c.GetV2PartiesParty(ctx, party, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2PartiesPartyResponse(rsp)
}

// PatchV2PartiesPartyWithBodyWithResponse request with arbitrary body returning *PatchV2PartiesPartyResponse
func (c *ClientWithResponses) PatchV2PartiesPartyWithBodyWithResponse(ctx context.Context, party string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2PartiesPartyResponse, error) {
	rsp, err := c.PatchV2PartiesPartyWithBody(ctx, party, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2PartiesPartyResponse(rsp)
}

func (c *ClientWithResponses) PatchV2PartiesPartyWithResponse(ctx context.Context, party string, body PatchV2PartiesPartyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2PartiesPartyResponse, error) {
	rsp, err := c.PatchV2PartiesParty(ctx, party, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2PartiesPartyResponse(rsp)
}

// PostV2StateActiveContractsWithBodyWithResponse request with arbitrary body returning *PostV2StateActiveContractsResponse
func (c *ClientWithResponses) PostV2StateActiveContractsWithBodyWithResponse(ctx context.Context, params *PostV2StateActiveContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2StateActiveContractsResponse, error) {
	rsp, err := c.PostV2StateActiveContractsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2StateActiveContractsResponse(rsp)
}

func (c *ClientWithResponses) PostV2StateActiveContractsWithResponse(ctx context.Context, params *PostV2StateActiveContractsParams, body PostV2StateActiveContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2StateActiveContractsResponse, error) {
	rsp, err := c.PostV2StateActiveContracts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2StateActiveContractsResponse(rsp)
}

// GetV2StateConnectedSynchronizersWithResponse request returning *GetV2StateConnectedSynchronizersResponse
func (c *ClientWithResponses) GetV2StateConnectedSynchronizersWithResponse(ctx context.Context, params *GetV2StateConnectedSynchronizersParams, reqEditors ...RequestEditorFn) (*GetV2StateConnectedSynchronizersResponse, error) {
	rsp, err := c.GetV2StateConnectedSynchronizers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2StateConnectedSynchronizersResponse(rsp)
}

// GetV2StateLatestPrunedOffsetsWithResponse request returning *GetV2StateLatestPrunedOffsetsResponse
func (c *ClientWithResponses) GetV2StateLatestPrunedOffsetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2StateLatestPrunedOffsetsResponse, error) {
	rsp, err := c.GetV2StateLatestPrunedOffsets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2StateLatestPrunedOffsetsResponse(rsp)
}

// GetV2StateLedgerEndWithResponse request returning *GetV2StateLedgerEndResponse
func (c *ClientWithResponses) GetV2StateLedgerEndWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2StateLedgerEndResponse, error) {
	rsp, err := c.GetV2StateLedgerEnd(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2StateLedgerEndResponse(rsp)
}

// PostV2UpdatesFlatsWithBodyWithResponse request with arbitrary body returning *PostV2UpdatesFlatsResponse
func (c *ClientWithResponses) PostV2UpdatesFlatsWithBodyWithResponse(ctx context.Context, params *PostV2UpdatesFlatsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesFlatsResponse, error) {
	rsp, err := c.PostV2UpdatesFlatsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesFlatsResponse(rsp)
}

func (c *ClientWithResponses) PostV2UpdatesFlatsWithResponse(ctx context.Context, params *PostV2UpdatesFlatsParams, body PostV2UpdatesFlatsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesFlatsResponse, error) {
	rsp, err := c.PostV2UpdatesFlats(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesFlatsResponse(rsp)
}

// PostV2UpdatesTransactionByIdWithBodyWithResponse request with arbitrary body returning *PostV2UpdatesTransactionByIdResponse
func (c *ClientWithResponses) PostV2UpdatesTransactionByIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByIdResponse, error) {
	rsp, err := c.PostV2UpdatesTransactionByIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesTransactionByIdResponse(rsp)
}

func (c *ClientWithResponses) PostV2UpdatesTransactionByIdWithResponse(ctx context.Context, body PostV2UpdatesTransactionByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByIdResponse, error) {
	rsp, err := c.PostV2UpdatesTransactionById(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesTransactionByIdResponse(rsp)
}

// PostV2UpdatesTransactionByOffsetWithBodyWithResponse request with arbitrary body returning *PostV2UpdatesTransactionByOffsetResponse
func (c *ClientWithResponses) PostV2UpdatesTransactionByOffsetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByOffsetResponse, error) {
	rsp, err := c.PostV2UpdatesTransactionByOffsetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesTransactionByOffsetResponse(rsp)
}

func (c *ClientWithResponses) PostV2UpdatesTransactionByOffsetWithResponse(ctx context.Context, body PostV2UpdatesTransactionByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesTransactionByOffsetResponse, error) {
	rsp, err := c.PostV2UpdatesTransactionByOffset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesTransactionByOffsetResponse(rsp)
}

// GetV2UpdatesTransactionTreeByIdUpdateIdWithResponse request returning *GetV2UpdatesTransactionTreeByIdUpdateIdResponse
func (c *ClientWithResponses) GetV2UpdatesTransactionTreeByIdUpdateIdWithResponse(ctx context.Context, updateId string, params *GetV2UpdatesTransactionTreeByIdUpdateIdParams, reqEditors ...RequestEditorFn) (*GetV2UpdatesTransactionTreeByIdUpdateIdResponse, error) {
	rsp, err := c.GetV2UpdatesTransactionTreeByIdUpdateId(ctx, updateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2UpdatesTransactionTreeByIdUpdateIdResponse(rsp)
}

// GetV2UpdatesTransactionTreeByOffsetOffsetWithResponse request returning *GetV2UpdatesTransactionTreeByOffsetOffsetResponse
func (c *ClientWithResponses) GetV2UpdatesTransactionTreeByOffsetOffsetWithResponse(ctx context.Context, offset int64, params *GetV2UpdatesTransactionTreeByOffsetOffsetParams, reqEditors ...RequestEditorFn) (*GetV2UpdatesTransactionTreeByOffsetOffsetResponse, error) {
	rsp, err := c.GetV2UpdatesTransactionTreeByOffsetOffset(ctx, offset, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2UpdatesTransactionTreeByOffsetOffsetResponse(rsp)
}

// PostV2UpdatesTreesWithBodyWithResponse request with arbitrary body returning *PostV2UpdatesTreesResponse
func (c *ClientWithResponses) PostV2UpdatesTreesWithBodyWithResponse(ctx context.Context, params *PostV2UpdatesTreesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesTreesResponse, error) {
	rsp, err := c.PostV2UpdatesTreesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesTreesResponse(rsp)
}

func (c *ClientWithResponses) PostV2UpdatesTreesWithResponse(ctx context.Context, params *PostV2UpdatesTreesParams, body PostV2UpdatesTreesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesTreesResponse, error) {
	rsp, err := c.PostV2UpdatesTrees(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesTreesResponse(rsp)
}

// PostV2UpdatesUpdateByIdWithBodyWithResponse request with arbitrary body returning *PostV2UpdatesUpdateByIdResponse
func (c *ClientWithResponses) PostV2UpdatesUpdateByIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByIdResponse, error) {
	rsp, err := c.PostV2UpdatesUpdateByIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesUpdateByIdResponse(rsp)
}

func (c *ClientWithResponses) PostV2UpdatesUpdateByIdWithResponse(ctx context.Context, body PostV2UpdatesUpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByIdResponse, error) {
	rsp, err := c.PostV2UpdatesUpdateById(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesUpdateByIdResponse(rsp)
}

// PostV2UpdatesUpdateByOffsetWithBodyWithResponse request with arbitrary body returning *PostV2UpdatesUpdateByOffsetResponse
func (c *ClientWithResponses) PostV2UpdatesUpdateByOffsetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByOffsetResponse, error) {
	rsp, err := c.PostV2UpdatesUpdateByOffsetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesUpdateByOffsetResponse(rsp)
}

func (c *ClientWithResponses) PostV2UpdatesUpdateByOffsetWithResponse(ctx context.Context, body PostV2UpdatesUpdateByOffsetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UpdatesUpdateByOffsetResponse, error) {
	rsp, err := c.PostV2UpdatesUpdateByOffset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UpdatesUpdateByOffsetResponse(rsp)
}

// GetV2UsersWithResponse request returning *GetV2UsersResponse
func (c *ClientWithResponses) GetV2UsersWithResponse(ctx context.Context, params *GetV2UsersParams, reqEditors ...RequestEditorFn) (*GetV2UsersResponse, error) {
	rsp, err := c.GetV2Users(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2UsersResponse(rsp)
}

// PostV2UsersWithBodyWithResponse request with arbitrary body returning *PostV2UsersResponse
func (c *ClientWithResponses) PostV2UsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UsersResponse, error) {
	rsp, err := c.PostV2UsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UsersResponse(rsp)
}

func (c *ClientWithResponses) PostV2UsersWithResponse(ctx context.Context, body PostV2UsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UsersResponse, error) {
	rsp, err := c.PostV2Users(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UsersResponse(rsp)
}

// DeleteV2UsersUserIdWithResponse request returning *DeleteV2UsersUserIdResponse
func (c *ClientWithResponses) DeleteV2UsersUserIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteV2UsersUserIdResponse, error) {
	rsp, err := c.DeleteV2UsersUserId(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteV2UsersUserIdResponse(rsp)
}

// GetV2UsersUserIdWithResponse request returning *GetV2UsersUserIdResponse
func (c *ClientWithResponses) GetV2UsersUserIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetV2UsersUserIdResponse, error) {
	rsp, err := c.GetV2UsersUserId(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2UsersUserIdResponse(rsp)
}

// PatchV2UsersUserIdWithBodyWithResponse request with arbitrary body returning *PatchV2UsersUserIdResponse
func (c *ClientWithResponses) PatchV2UsersUserIdWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdResponse, error) {
	rsp, err := c.PatchV2UsersUserIdWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2UsersUserIdResponse(rsp)
}

func (c *ClientWithResponses) PatchV2UsersUserIdWithResponse(ctx context.Context, userId string, body PatchV2UsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdResponse, error) {
	rsp, err := c.PatchV2UsersUserId(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2UsersUserIdResponse(rsp)
}

// PatchV2UsersUserIdIdentityProviderIdWithBodyWithResponse request with arbitrary body returning *PatchV2UsersUserIdIdentityProviderIdResponse
func (c *ClientWithResponses) PatchV2UsersUserIdIdentityProviderIdWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdIdentityProviderIdResponse, error) {
	rsp, err := c.PatchV2UsersUserIdIdentityProviderIdWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2UsersUserIdIdentityProviderIdResponse(rsp)
}

func (c *ClientWithResponses) PatchV2UsersUserIdIdentityProviderIdWithResponse(ctx context.Context, userId string, body PatchV2UsersUserIdIdentityProviderIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdIdentityProviderIdResponse, error) {
	rsp, err := c.PatchV2UsersUserIdIdentityProviderId(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2UsersUserIdIdentityProviderIdResponse(rsp)
}

// GetV2UsersUserIdRightsWithResponse request returning *GetV2UsersUserIdRightsResponse
func (c *ClientWithResponses) GetV2UsersUserIdRightsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetV2UsersUserIdRightsResponse, error) {
	rsp, err := c.GetV2UsersUserIdRights(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2UsersUserIdRightsResponse(rsp)
}

// PatchV2UsersUserIdRightsWithBodyWithResponse request with arbitrary body returning *PatchV2UsersUserIdRightsResponse
func (c *ClientWithResponses) PatchV2UsersUserIdRightsWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdRightsResponse, error) {
	rsp, err := c.PatchV2UsersUserIdRightsWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2UsersUserIdRightsResponse(rsp)
}

func (c *ClientWithResponses) PatchV2UsersUserIdRightsWithResponse(ctx context.Context, userId string, body PatchV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchV2UsersUserIdRightsResponse, error) {
	rsp, err := c.PatchV2UsersUserIdRights(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchV2UsersUserIdRightsResponse(rsp)
}

// PostV2UsersUserIdRightsWithBodyWithResponse request with arbitrary body returning *PostV2UsersUserIdRightsResponse
func (c *ClientWithResponses) PostV2UsersUserIdRightsWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV2UsersUserIdRightsResponse, error) {
	rsp, err := c.PostV2UsersUserIdRightsWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UsersUserIdRightsResponse(rsp)
}

func (c *ClientWithResponses) PostV2UsersUserIdRightsWithResponse(ctx context.Context, userId string, body PostV2UsersUserIdRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV2UsersUserIdRightsResponse, error) {
	rsp, err := c.PostV2UsersUserIdRights(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV2UsersUserIdRightsResponse(rsp)
}

// GetV2VersionWithResponse request returning *GetV2VersionResponse
func (c *ClientWithResponses) GetV2VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV2VersionResponse, error) {
	rsp, err := c.GetV2Version(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV2VersionResponse(rsp)
}

// ParsePostV2CommandsAsyncSubmitResponse parses an HTTP response from a PostV2CommandsAsyncSubmitWithResponse call
func ParsePostV2CommandsAsyncSubmitResponse(rsp *http.Response) (*PostV2CommandsAsyncSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2CommandsAsyncSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubmitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2CommandsAsyncSubmitReassignmentResponse parses an HTTP response from a PostV2CommandsAsyncSubmitReassignmentWithResponse call
func ParsePostV2CommandsAsyncSubmitReassignmentResponse(rsp *http.Response) (*PostV2CommandsAsyncSubmitReassignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2CommandsAsyncSubmitReassignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubmitReassignmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2CommandsCompletionsResponse parses an HTTP response from a PostV2CommandsCompletionsWithResponse call
func ParsePostV2CommandsCompletionsResponse(rsp *http.Response) (*PostV2CommandsCompletionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2CommandsCompletionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CompletionStreamResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2CommandsSubmitAndWaitResponse parses an HTTP response from a PostV2CommandsSubmitAndWaitWithResponse call
func ParsePostV2CommandsSubmitAndWaitResponse(rsp *http.Response) (*PostV2CommandsSubmitAndWaitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2CommandsSubmitAndWaitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubmitAndWaitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2CommandsSubmitAndWaitForReassignmentResponse parses an HTTP response from a PostV2CommandsSubmitAndWaitForReassignmentWithResponse call
func ParsePostV2CommandsSubmitAndWaitForReassignmentResponse(rsp *http.Response) (*PostV2CommandsSubmitAndWaitForReassignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2CommandsSubmitAndWaitForReassignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsSubmitAndWaitForReassignmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2CommandsSubmitAndWaitForTransactionResponse parses an HTTP response from a PostV2CommandsSubmitAndWaitForTransactionWithResponse call
func ParsePostV2CommandsSubmitAndWaitForTransactionResponse(rsp *http.Response) (*PostV2CommandsSubmitAndWaitForTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2CommandsSubmitAndWaitForTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsSubmitAndWaitForTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2CommandsSubmitAndWaitForTransactionTreeResponse parses an HTTP response from a PostV2CommandsSubmitAndWaitForTransactionTreeWithResponse call
func ParsePostV2CommandsSubmitAndWaitForTransactionTreeResponse(rsp *http.Response) (*PostV2CommandsSubmitAndWaitForTransactionTreeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2CommandsSubmitAndWaitForTransactionTreeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsSubmitAndWaitForTransactionTreeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2EventsEventsByContractIdResponse parses an HTTP response from a PostV2EventsEventsByContractIdWithResponse call
func ParsePostV2EventsEventsByContractIdResponse(rsp *http.Response) (*PostV2EventsEventsByContractIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2EventsEventsByContractIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsGetEventsByContractIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2IdpsResponse parses an HTTP response from a GetV2IdpsWithResponse call
func ParseGetV2IdpsResponse(rsp *http.Response) (*GetV2IdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2IdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIdentityProviderConfigsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2IdpsResponse parses an HTTP response from a PostV2IdpsWithResponse call
func ParsePostV2IdpsResponse(rsp *http.Response) (*PostV2IdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2IdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateIdentityProviderConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteV2IdpsIdpIdResponse parses an HTTP response from a DeleteV2IdpsIdpIdWithResponse call
func ParseDeleteV2IdpsIdpIdResponse(rsp *http.Response) (*DeleteV2IdpsIdpIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteV2IdpsIdpIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteIdentityProviderConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2IdpsIdpIdResponse parses an HTTP response from a GetV2IdpsIdpIdWithResponse call
func ParseGetV2IdpsIdpIdResponse(rsp *http.Response) (*GetV2IdpsIdpIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2IdpsIdpIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIdentityProviderConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchV2IdpsIdpIdResponse parses an HTTP response from a PatchV2IdpsIdpIdWithResponse call
func ParsePatchV2IdpsIdpIdResponse(rsp *http.Response) (*PatchV2IdpsIdpIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2IdpsIdpIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateIdentityProviderConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2InteractiveSubmissionExecuteResponse parses an HTTP response from a PostV2InteractiveSubmissionExecuteWithResponse call
func ParsePostV2InteractiveSubmissionExecuteResponse(rsp *http.Response) (*PostV2InteractiveSubmissionExecuteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2InteractiveSubmissionExecuteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExecuteSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2InteractiveSubmissionPreferredPackageVersionResponse parses an HTTP response from a GetV2InteractiveSubmissionPreferredPackageVersionWithResponse call
func ParseGetV2InteractiveSubmissionPreferredPackageVersionResponse(rsp *http.Response) (*GetV2InteractiveSubmissionPreferredPackageVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2InteractiveSubmissionPreferredPackageVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPreferredPackageVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2InteractiveSubmissionPrepareResponse parses an HTTP response from a PostV2InteractiveSubmissionPrepareWithResponse call
func ParsePostV2InteractiveSubmissionPrepareResponse(rsp *http.Response) (*PostV2InteractiveSubmissionPrepareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2InteractiveSubmissionPrepareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsPrepareSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2PackagesResponse parses an HTTP response from a GetV2PackagesWithResponse call
func ParseGetV2PackagesResponse(rsp *http.Response) (*GetV2PackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2PackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPackagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2PackagesResponse parses an HTTP response from a PostV2PackagesWithResponse call
func ParsePostV2PackagesResponse(rsp *http.Response) (*PostV2PackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2PackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadDarFileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2PackagesPackageIdResponse parses an HTTP response from a GetV2PackagesPackageIdWithResponse call
func ParseGetV2PackagesPackageIdResponse(rsp *http.Response) (*GetV2PackagesPackageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2PackagesPackageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2PackagesPackageIdStatusResponse parses an HTTP response from a GetV2PackagesPackageIdStatusWithResponse call
func ParseGetV2PackagesPackageIdStatusResponse(rsp *http.Response) (*GetV2PackagesPackageIdStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2PackagesPackageIdStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPackageStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2PartiesResponse parses an HTTP response from a GetV2PartiesWithResponse call
func ParseGetV2PartiesResponse(rsp *http.Response) (*GetV2PartiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2PartiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListKnownPartiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2PartiesResponse parses an HTTP response from a PostV2PartiesWithResponse call
func ParsePostV2PartiesResponse(rsp *http.Response) (*PostV2PartiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2PartiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllocatePartyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2PartiesParticipantIdResponse parses an HTTP response from a GetV2PartiesParticipantIdWithResponse call
func ParseGetV2PartiesParticipantIdResponse(rsp *http.Response) (*GetV2PartiesParticipantIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2PartiesParticipantIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetParticipantIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2PartiesPartyResponse parses an HTTP response from a GetV2PartiesPartyWithResponse call
func ParseGetV2PartiesPartyResponse(rsp *http.Response) (*GetV2PartiesPartyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2PartiesPartyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPartiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchV2PartiesPartyResponse parses an HTTP response from a PatchV2PartiesPartyWithResponse call
func ParsePatchV2PartiesPartyResponse(rsp *http.Response) (*PatchV2PartiesPartyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2PartiesPartyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePartyDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2StateActiveContractsResponse parses an HTTP response from a PostV2StateActiveContractsWithResponse call
func ParsePostV2StateActiveContractsResponse(rsp *http.Response) (*PostV2StateActiveContractsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2StateActiveContractsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JsGetActiveContractsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2StateConnectedSynchronizersResponse parses an HTTP response from a GetV2StateConnectedSynchronizersWithResponse call
func ParseGetV2StateConnectedSynchronizersResponse(rsp *http.Response) (*GetV2StateConnectedSynchronizersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2StateConnectedSynchronizersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConnectedSynchronizersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2StateLatestPrunedOffsetsResponse parses an HTTP response from a GetV2StateLatestPrunedOffsetsWithResponse call
func ParseGetV2StateLatestPrunedOffsetsResponse(rsp *http.Response) (*GetV2StateLatestPrunedOffsetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2StateLatestPrunedOffsetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLatestPrunedOffsetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2StateLedgerEndResponse parses an HTTP response from a GetV2StateLedgerEndWithResponse call
func ParseGetV2StateLedgerEndResponse(rsp *http.Response) (*GetV2StateLedgerEndResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2StateLedgerEndResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLedgerEndResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UpdatesFlatsResponse parses an HTTP response from a PostV2UpdatesFlatsWithResponse call
func ParsePostV2UpdatesFlatsResponse(rsp *http.Response) (*PostV2UpdatesFlatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UpdatesFlatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JsGetUpdatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UpdatesTransactionByIdResponse parses an HTTP response from a PostV2UpdatesTransactionByIdWithResponse call
func ParsePostV2UpdatesTransactionByIdResponse(rsp *http.Response) (*PostV2UpdatesTransactionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UpdatesTransactionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsGetTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UpdatesTransactionByOffsetResponse parses an HTTP response from a PostV2UpdatesTransactionByOffsetWithResponse call
func ParsePostV2UpdatesTransactionByOffsetResponse(rsp *http.Response) (*PostV2UpdatesTransactionByOffsetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UpdatesTransactionByOffsetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsGetTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2UpdatesTransactionTreeByIdUpdateIdResponse parses an HTTP response from a GetV2UpdatesTransactionTreeByIdUpdateIdWithResponse call
func ParseGetV2UpdatesTransactionTreeByIdUpdateIdResponse(rsp *http.Response) (*GetV2UpdatesTransactionTreeByIdUpdateIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2UpdatesTransactionTreeByIdUpdateIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsGetTransactionTreeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2UpdatesTransactionTreeByOffsetOffsetResponse parses an HTTP response from a GetV2UpdatesTransactionTreeByOffsetOffsetWithResponse call
func ParseGetV2UpdatesTransactionTreeByOffsetOffsetResponse(rsp *http.Response) (*GetV2UpdatesTransactionTreeByOffsetOffsetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2UpdatesTransactionTreeByOffsetOffsetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsGetTransactionTreeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UpdatesTreesResponse parses an HTTP response from a PostV2UpdatesTreesWithResponse call
func ParsePostV2UpdatesTreesResponse(rsp *http.Response) (*PostV2UpdatesTreesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UpdatesTreesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JsGetUpdateTreesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UpdatesUpdateByIdResponse parses an HTTP response from a PostV2UpdatesUpdateByIdWithResponse call
func ParsePostV2UpdatesUpdateByIdResponse(rsp *http.Response) (*PostV2UpdatesUpdateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UpdatesUpdateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsGetUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UpdatesUpdateByOffsetResponse parses an HTTP response from a PostV2UpdatesUpdateByOffsetWithResponse call
func ParsePostV2UpdatesUpdateByOffsetResponse(rsp *http.Response) (*PostV2UpdatesUpdateByOffsetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UpdatesUpdateByOffsetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsGetUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2UsersResponse parses an HTTP response from a GetV2UsersWithResponse call
func ParseGetV2UsersResponse(rsp *http.Response) (*GetV2UsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2UsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UsersResponse parses an HTTP response from a PostV2UsersWithResponse call
func ParsePostV2UsersResponse(rsp *http.Response) (*PostV2UsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteV2UsersUserIdResponse parses an HTTP response from a DeleteV2UsersUserIdWithResponse call
func ParseDeleteV2UsersUserIdResponse(rsp *http.Response) (*DeleteV2UsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteV2UsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2UsersUserIdResponse parses an HTTP response from a GetV2UsersUserIdWithResponse call
func ParseGetV2UsersUserIdResponse(rsp *http.Response) (*GetV2UsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2UsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchV2UsersUserIdResponse parses an HTTP response from a PatchV2UsersUserIdWithResponse call
func ParsePatchV2UsersUserIdResponse(rsp *http.Response) (*PatchV2UsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2UsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchV2UsersUserIdIdentityProviderIdResponse parses an HTTP response from a PatchV2UsersUserIdIdentityProviderIdWithResponse call
func ParsePatchV2UsersUserIdIdentityProviderIdResponse(rsp *http.Response) (*PatchV2UsersUserIdIdentityProviderIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2UsersUserIdIdentityProviderIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserIdentityProviderIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2UsersUserIdRightsResponse parses an HTTP response from a GetV2UsersUserIdRightsWithResponse call
func ParseGetV2UsersUserIdRightsResponse(rsp *http.Response) (*GetV2UsersUserIdRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2UsersUserIdRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUserRightsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchV2UsersUserIdRightsResponse parses an HTTP response from a PatchV2UsersUserIdRightsWithResponse call
func ParsePatchV2UsersUserIdRightsResponse(rsp *http.Response) (*PatchV2UsersUserIdRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchV2UsersUserIdRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevokeUserRightsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostV2UsersUserIdRightsResponse parses an HTTP response from a PostV2UsersUserIdRightsWithResponse call
func ParsePostV2UsersUserIdRightsResponse(rsp *http.Response) (*PostV2UsersUserIdRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV2UsersUserIdRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GrantUserRightsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetV2VersionResponse parses an HTTP response from a GetV2VersionWithResponse call
func ParseGetV2VersionResponse(rsp *http.Response) (*GetV2VersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2VersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLedgerApiVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest JsCantonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
